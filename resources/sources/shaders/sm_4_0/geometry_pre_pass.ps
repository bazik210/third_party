////////////////////////////////////////////////////////////////////////////
//	Created		: 13.07.2011
//	Author		: Nikolay Partas
//	Copyright (C) GSC Game World - 2011
////////////////////////////////////////////////////////////////////////////

/*	$DEFINES$:
		GLOBAL_ALLOW_STEEPPARALLAX,
		GLOBAL_FP16_BLEND,
		GLOBAL_GBUFFER_POS_PACKING,
		GLOBAL_GBUFFER_NORMAL_PACKING,
		GLOBAL_USE_BRANCHING,
		
		CONFIG_VERTEX_INPUT_TYPE,
		CONFIG_TANISOTROPIC_DIRECTION,
		CONFIG_TDIFFUSE,
		CONFIG_TNORMAL,
		CONFIG_TDETAIL_NORMAL,
		CONFIG_PARALLAX,
		CONFIG_TSPECULAR_INTENSITY,
		CONFIG_TSPECULAR_POWER,
		CONFIG_TDIFFUSE_POWER,
		CONFIG_TRANSLUCENCY,
		CONFIG_EMISSIVE,
		CONFIG_TFRESNEL_AT_0_DEGREE,
		CONFIG_TDETAIL,
		CONFIG_ALPHA_TEST,
		CONFIG_REFLECTION,
		CONFIG_VARIATION_MASK,
*/
#include "common.h"
#include "v2p_common.h"

#include "psf_diffuse.h"
#include "psf_alpha_test.h"
#include "psf_detail.h"
#include "psf_normal.h"
#include "psf_parallax.h"
#include "psf_translucent.h"
#include "psf_tspecular_intensity.h"
#include "psf_tspecular_power.h"
#include "psf_tdiffuse_power.h"
#include "psf_emissive.h"
#include "psf_make_tangent_transform.h"
#include "psf_reflection.h"
#include "psf_fresnel.h"
#include "psf_tc_modifiers.h"

#include "material.h"
#include "vertex_input.h"

#if	CONFIG_EMISSIVE || (CONFIG_REFLECTION == 1)
#	define RT_EXTENTION_TARGET	1
#endif

#include "gbuffer.h"
#include "psf_emissive_write.h"

uniform float4 screen_res;

Texture2D t_roughness;

Texture2D t_height_map;
Texture2D t_fresnel_at_0_degree;
Texture2D t_detail_normal;
Texture2D t_anisotropic_direction;

float object_transparency_scale;

float4 detail_normal_parameters;
static const float2 detail_normal_multiplier = detail_normal_parameters.xy;
static const float2 detail_normal_tile = detail_normal_parameters.zw;

// roughness.xy, min, max
float2 roughness_uv_parameters;

float alpha_ref_parameter;

void	main(in vertex_output_struct input,
			 out float4 out_depth_render_target			: SV_Target0,
			 out float4 out_normals_render_target		: SV_Target1,
			 out float4 out_tangents_render_target		: SV_Target2,
			 in bool is_front_face 						: SV_IsFrontFace)
{
	material_parameters parameters 		= get_material_parameters(input);
	fill_material_parameters			(parameters);
	
	float3	 	normal 					= parameters.normal;
	float2 		tc						= parameters.tc;
	
	float3x3	tbn_matrix				= parameters.tangent_to_viewspace;
	
	// for two-sided lighting
	if (!is_front_face)
	{
		tbn_matrix[0][2]				*= -1.0f;
		tbn_matrix[1][2]				*= -1.0f;
		tbn_matrix[2][2]				*= -1.0f;
	}
	
	if( CONFIG_PARALLAX)
		tc 								= psf_parallax(
			t_height_map, 
			parameters.world_view_position.xyz, 
			tc, 
			tbn_matrix
		);
	
	if( CONFIG_ALPHA_TEST)
	{
		float alpha						= t_base.SampleLevel(s_base, tc, 0).a;
		clip							(alpha - alpha_ref_parameter);
	}
	
	if( CONFIG_TNORMAL)
	{
		if (CONFIG_TDETAIL_NORMAL)
		{
			// TODO: add special functions for normal map reading!!!
			float2 tiled_tc				= parameters.tc * detail_normal_tile;
			float3 normal_details		= float3(
				detail_normal_multiplier * (t_detail_normal.Sample(s_normal, tiled_tc).wy * 2.0f - 1.0f), 
				0.0f
			);
			normal_details.y 			= -normal_details.y;
			
			normal						= psf_tnormal_detailed(
				t_normal, normal_details, 
				tbn_matrix, 
				tc
			);
		}
		else
		{
			normal						= psf_tnormal(t_normal, tbn_matrix, tc, float3(1,1,1));
		}
	}
	else
		normal							= normalize(mul(tbn_matrix, float3(0.0f,0.0f,1.0f)));

	
	float2 	roughness 					= roughness_uv_parameters.xy / 255.0f;
	if (CONFIG_TSPECULAR_POWER) // TODO: error when packing values [0..1]
		roughness 						= psf_tspecular_power(t_roughness, tc);
	
	//float3 tangent						= normalize( transpose(tbn_matrix)[1] ) * 0.5f + 0.5f;
	//float2 packed_tangent				= normal.x != 0.f ? tangent.yz : (normal.y != 0.f ? tangent.xz : tangent.xy);
	
#if CONFIG_TANISOTROPIC_DIRECTION
	float3 anisotropic_direction		= t_anisotropic_direction.Sample(s_base, tc).xyz;
	anisotropic_direction				= normalize(
		mul(
			tbn_matrix, 
			float3(anisotropic_direction.xy * 2.0f - 1.0f, 0.0f)
		)
	).xyz;
	
	//packed_tangent						= normalize(mul(tbn_matrix, float3(anisotropic_direction.xy * 2.0f - 1.0f, 1))).xy;
	//packed_tangent						= packed_tangent * 0.5f + 0.5f;
#endif // CONFIG_TANISOTROPIC_DIRECTION
	
	float fresnel_at_0_degree_value 	= fresnel_at_0_degree;
	
#if CONFIG_TFRESNEL_AT_0_DEGREE
	fresnel_at_0_degree_value 			= t_fresnel_at_0_degree.Sample(s_base, tc).x;
#endif // #if CONFIG_TFRESNEL_AT_0_DEGREE	
	
	//float packed_fresnel_at_0_degree_and_specular_power
	//	= (256.0f * floor(fresnel_at_0_degree_value) + floor(roughness)) / 65535.0f;
	
	out_depth_render_target				= float4(
		sqrt(parameters.world_view_position.z * near_far_invn_invf.w), 
		0.0f,
		roughness
	);
	
	out_normals_render_target			= float4(
		normal.xy * 0.5f + 0.5f,
		fresnel_at_0_degree_value,
		normal.z > 0 ? 0 : 1
	);
	
	clip(parameters.color.a - 0.1f);
	
#if CONFIG_TANISOTROPIC_DIRECTION	
	out_tangents_render_target			= float4(normalize(cross(anisotropic_direction, normal)) * 0.5f + 0.5f, 1.0f);
#else // #if CONFIG_TANISOTROPIC_DIRECTION
	out_tangents_render_target			= float4(normalize(cross(mul(tbn_matrix, float3(1, 0, 0)), normal)) * 0.5f + 0.5f, 1.0f);
#endif // #if CONFIG_TANISOTROPIC_DIRECTION
}
















