////////////////////////////////////////////////////////////////////////////
//	Created		: 15.07.2011
//	Author		: Nikolay Partas
//	Copyright (C) GSC Game World - 2011
////////////////////////////////////////////////////////////////////////////

/*	$DEFINES$: 
		GLOBAL_ALLOW_STEEPPARALLAX,
		GLOBAL_GBUFFER_POS_PACKING,
		GLOBAL_GBUFFER_NORMAL_PACKING,
		
		CONFIG_TNORMAL,
		CONFIG_PARALLAX,
*/

#include "common.h"
#include "gbuffer.h"

#include "v2p_common.h"

#include "psf_normal.h"
#include "psf_parallax.h"
#include "psf_make_tangent_transform.h"

#define V2P_PARAM_TC0			1

#if CONFIG_PARALLAX || CONFIG_TNORMAL
#	define V2P_PARAM_TANGENTS		1
#endif

#include "v2p_terrain.h"

#include "gamma_correction.h"



uniform sampler       		s_array;
uniform Texture2DArray      t_array_diffuse;
uniform Texture2DArray      t_array_nmap;
uniform Texture2DArray      t_array_spec;

Texture2D					t_height;
Texture2D					t_color;
Texture2D					t_params;
Texture2D					t_tex_ids;
Texture2D					t_tc_shift;


Texture2D					t_diffuse_detail;
Texture2D					t_normal_detail;

Texture2D  					t_accumulator_dif;
Texture2D  					t_accumulator_spec;
Texture2D  					t_ssao_accumulator;


uniform float4				terrain_size;
uniform float4				start_corner;
uniform float4				screen_res;

float4 						far_fog_color_and_distance;
float 						near_fog_distance;
float4 						ambient_color;

float4 environment_skylight_upper_color;
float4 environment_skylight_lower_color;
float4 environment_skylight_parameters;

void	main(in v2p_terrain input,
			 out float4 rt0: SV_Target0)
{
	v2p_common		data;
	fill_v2p_common ( input, data );

	float2 tc 		= data.tc * terrain_size.zw; //float2( input.P.x - start_corner.x, -(input.P.z - start_corner.z)) * terrain_size.zw;
	float2 tc_shift	= t_tc_shift.Sample( s_rtlinear, tc).xy;
	tc_shift		= float2( -1.f, 1.f)*tc_shift*( (64.f*2.f) - 64.f);
	tc_shift		*= 	terrain_size.zw;

	float4 color	= t_color.Sample( s_rtlinear, tc);
	float4 params	= t_params.Sample( s_rtlinear, tc);
	float4 tex_ids	= t_tex_ids.Sample( s_rtlinear, tc);
	
	const float m = 255.f;
	float alpha0, alpha1, alpha2;
	alpha0 = params.x;
	alpha1 = params.y;
	alpha2 = params.z;
	
	
	float tex_ind0, tex_ind1, tex_ind2;
	tex_ind0 = tex_ids.x;
	tex_ind1 = tex_ids.y;
	tex_ind2 = tex_ids.z;
	
	float3 asd = float3( tex_ind0, tex_ind1, tex_ind2);
	const float tc_tiles = 8.f;
	
	
	
	float4 diffse_detail =	t_diffuse_detail.Sample( s_array, (tc + tc_shift) * tc_tiles * 10.0f);
	
	
	float4 c0 = 	t_array_diffuse.Sample( s_array, float3( (tc + tc_shift)*tc_tiles, (asd.x*255.f)));
	float4 c1 = 	t_array_diffuse.Sample( s_array, float3( (tc + tc_shift)*tc_tiles, (asd.y*255.f)));
	float4 c2 = 	t_array_diffuse.Sample( s_array, float3( (tc + tc_shift)*tc_tiles, (asd.z*255.f)));
	
	float3x3 tangent_trans = psf_make_tangent_transform( data.tbn_x, data.tbn_y, data.tbn_z);
	float3 n0 = 	psf_tnormal( t_array_nmap, (tc + tc_shift)*tc_tiles, (asd.x*255.f), float3(1,1,1)).xyz;
	float3 n1 = 	psf_tnormal( t_array_nmap, (tc + tc_shift)*tc_tiles, (asd.y*255.f), float3(1,1,1)).xyz;
	float3 n2 = 	psf_tnormal( t_array_nmap, (tc + tc_shift)*tc_tiles, (asd.z*255.f), float3(1,1,1)).xyz;
	
	float3 normal_detail =	psf_tnormal(t_normal_detail, (tc + tc_shift) * tc_tiles * 10.0f, float3(1,1,1)).xyz;
	
	float4 s0 = 	t_array_spec.Sample( s_array, float3( (tc + tc_shift)*tc_tiles, (asd.x*255.f)));
	float4 s1 = 	t_array_spec.Sample( s_array, float3( (tc + tc_shift)*tc_tiles, (asd.y*255.f)));
	float4 s2 = 	t_array_spec.Sample( s_array, float3( (tc + tc_shift)*tc_tiles, (asd.z*255.f)));	
	
	float3 tex_c  = (c0.rgb * alpha0 + c1.rgb * alpha1 + c2.rgb * alpha2);
	
	float a_grey  = 1 - (alpha0 + alpha1 + alpha2);	
	

	
	
	float3 normal = input.normal;
	
	if( CONFIG_TNORMAL)
		normal	= normalize( n0 * alpha0 + n1 * alpha1 + n2 * alpha2 + a_grey*float3( 0.f, 0.f, 1.f));
	
	normal = normalize(mul( tangent_trans, normal));

	
	
	float3 c 	  =	(tex_c + (a_grey * 0.5)) * color.rgb * 2;
	
	float3 spec   = (s0.rgb * alpha0 + s1.rgb * alpha1 + s2.rgb * alpha2);
	
	float3 diffuse_color				= c.rgb;
	float3 specular_color				= spec.x;
	
	const float2 screen_uv				= data.hposition.xy / screen_res.xy;
	
	float4 decal_diffuse_and_alpha 		= t_decals_diffuse.Sample(s_diffuse, screen_uv);
	diffuse_color.rgb					= diffuse_color.rgb * (1.0f - decal_diffuse_and_alpha.a) + decal_diffuse_and_alpha.rgb;
	
	const float ssao_result				= t_ssao_accumulator.Sample(s_base, screen_uv).x;
	const float3 accum_diffuse			= t_accumulator_dif.Sample(s_accumulator, screen_uv).rgb;
	const float3 accum_specular			= t_accumulator_spec.Sample(s_accumulator, screen_uv).rgb;
	const float3 ambient_material_color = float3(0.0f, 0.0f, 0.0f);
	
	float3 emission_color				= (0.0f).xxx;
	
	
	float3 from_sky						= normalize(mul(m_V, float4(0.0f, -1.0f, 0.0f, 0.0f)).xyz);
	float3 from_ground					= normalize(mul(m_V, float4(0.0f, 1.0f, 0.0f, 0.0f)).xyz);
	
<<<<<<< local
	float sky_dot_normal				= pow(saturate(dot(-from_sky, normal)), 3.0f);
	float ground_dot_normal				= pow(saturate(dot(-from_ground, normal)), 3.0f);
=======
	float sky_dot_normal				= pow(dot(-from_sky, normal   ) * 0.5 + 0.5f, environment_skylight_parameters.x);
	float ground_dot_normal				= pow(dot(-from_ground, normal) * 0.5 + 0.5f, environment_skylight_parameters.y);
>>>>>>> other
	
	float3 skylight_color				= float4(sky_dot_normal * environment_skylight_upper_color.a * convert_to_linear_space(environment_skylight_upper_color.rgb), 1.0f);
	skylight_color						+= float4(ground_dot_normal * environment_skylight_lower_color.a * convert_to_linear_space(environment_skylight_lower_color.rgb), 1.0f);
	
	float3 final_color 					= 
		float3(
			emission_color
			+ 
			diffuse_color.rgb 
			* 
			(
				accum_diffuse 
				+
				(length(accum_diffuse) > 0.0f ? 1.0f : ssao_result) * (convert_to_linear_space(ambient_color.rgb) + skylight_color)
				+
				ssao_result * convert_to_linear_space(ambient_material_color)
			)
			+ 
			specular_color * accum_specular
		);
	
	
	// Apply fog.
	final_color							= lerp(
		final_color,
		far_fog_color_and_distance.rgb,
		1.0f - saturate(
			exp(
				-(data.position.z - near_fog_distance) 
				/ 
				far_fog_color_and_distance.a
			)
		)
	);
	
	rt0									= float4(final_color, 1.0f);
}
