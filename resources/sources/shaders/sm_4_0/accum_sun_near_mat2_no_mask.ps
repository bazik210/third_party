#include "common.h"
#include "light.h"
#include "shadow.h"
#include "gbuffer.h"
#include "light_accumulator.h"
#include "parallel_light.h"
#include "light_ps_helper.h"

#define EPS	(0.9f/255.f)
#define CLIP_THRESHOLD	(1.0f/255.f)

light_accumulator 	main		( v2p_sun I ) : SV_TARGET
{
//	float4  _N		= t_normal.Sample 	(s_normal,   	I.Tex0);
//	float4	_N	= gbuffer_read_rt_normal	( I.Tex0);
	
	g_data gb	= gbuffer_read	( I.Tex0, I.eye_ray);
		
	float	L 		= /*_N.w **/ dot( light_direction.xyz, gb.normal.xyz) + EPS; // Use hemisphere as approximation of max light
  
	light_accumulator result;
	[branch] if( -( L - CLIP_THRESHOLD) < 0)
	{
		result.diffuse 	= float4 ( 0.f, 0.f, 0.f, 0.f);
		result.specular = float4 ( 0.f, 0.f, 0.f, 0.f);
	}
	else
	{
//		float2	light 	= phong_infinity ( gb.position.xyz, gb.normal.xyz, light_direction.xyz, gb.specular_power, gb.sh_param, gb.diffuse_power);
//
//		// ----- shadow
//	//  	float4 	P4 	= float4	(_P.x,_P.y,_P.z,1.f);
//	//	float4 	PS	= mul		(m_shadow, 	P4);
//	//	float 	s 	= sunmask	(P4);
//		#ifdef 	USE_SJITTER
//	//	  s 	*= shadowtest_sun 	(PS,tcJ);
//		#else
//	//	  s 	*= shadow		(PS);
//		#endif
//		
//		float s=1;
//		
////		float4 _P1	= gbuffer_read_rt_position	( I.Tex0+sin(I.Tex0+sin(I.Tex0)), I.eye_ray);
////		float4 _N1	= gbuffer_read_rt_normal	( I.Tex0+sin(I.Tex0+cos(I.Tex0)));
//
//		float4 _N = float4( gb.normal, 1.f); 
//		float4 _P = float4( gb.position, 1.f); 
//
//		float4 fake = saturate(float4(0.9,0,0,0.9) + 0.01*(sqrt(_P)+sqrt(_N)+sin(_P)+sin(_N)+ pow(_P,_P.x)+ pow(_N,_N.x)));
//		
//		result.diffuse = float4( fake.rgb * light_color.rgb * light.x * s / LIGHT_ACCUMULATOR_MAGNIFY_FACTOR, 0);
//		result.specular = float4( fake.rgb * light_color.rgb * light.y * s / LIGHT_ACCUMULATOR_MAGNIFY_FACTOR, 0);
//		//result =  		blend		/*(float4(1,0,0,1),tc);//*/( fake*light_color * light * s, I.Tex0);
		return
			get_light_accumulator(
				light_color,
				parallel_light( gb, I.Tex0 )
			);
	}
	return result;
}
