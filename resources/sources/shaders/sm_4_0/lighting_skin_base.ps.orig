////////////////////////////////////////////////////////////////////////////
//	Created		: 09.12.2010
//	Author		: Nikolay Partas
//	Copyright (C) GSC Game World - 2010
////////////////////////////////////////////////////////////////////////////

/*	$DEFINES$:
		GLOBAL_ALLOW_STEEPPARALLAX,
		GLOBAL_FP16_BLEND,
		GLOBAL_GBUFFER_POS_PACKING,
		GLOBAL_GBUFFER_NORMAL_PACKING,
		GLOBAL_USE_BRANCHING,
		GLOBAL_USE_LOOP_UNROLLING,
		
		CONFIG_VERTEX_INPUT_TYPE,
		CONFIG_TDIFFUSE,
		CONFIG_TNORMAL,
		CONFIG_TSPECULAR_INTENSITY,
*/

#include "common.h"


#include "light_accumulator.h"
#include "light.h"
#include "positional_light.h"

#include "psf_alpha_test.h"
#include "psf_detail.h"
#include "psf_normal.h"
#include "psf_parallax.h"
#include "psf_translucent.h"
#include "psf_tspecular_intensity.h"
#include "psf_tspecular_power.h"
#include "psf_tdiffuse_power.h"
#include "psf_emissive.h"
#include "psf_make_tangent_transform.h"
#include "psf_fresnel.h"

#include "gbuffer.h"
#include "material.h"
#include "vertex_input.h"

Texture2D t_specular_intensity;

uniform float4 forward_light_position_and_range;
uniform float3 forward_light_color;

float light_attenuation;
// TODO: Optimize this shader.

float4 	main			( in vertex_output_struct input,
						  in float4	hposition: SV_Position): SV_TARGET0
{
	material_parameters parameters = get_material_parameters(input);
	fill_material_parameters(parameters);
	
	float3 		position 		= 	parameters.world_view_position.xyz;
	float3	 	normal 			= 	parameters.normal;
	float2 		tc				= 	0.f;
	float2 		tcdetail		= 	0.f;
	float3x3	tangent_trans	= 	0.f;
	
	tc							= 	parameters.tc;
	
	tangent_trans 				= 	parameters.tangent_to_viewspace;
	
	float3 	specular_intensity 	= 	solid_color_specular.w;
	if( CONFIG_TSPECULAR_INTENSITY)
		specular_intensity 		= 	psf_tspecular_intensity( t_specular_intensity, tc);
	
	float 	specular_power 		= 	solid_material_params.x;
	
	float 	diffuse_power 		= 	255.0f;
	
	float3 final_color = 0;
	
	static const int num_samples = 8;
	
	// TODO: Get texture dimentions.
	static const float2 texture_space_offsets[num_samples] = 
	{
		float2(-1, 0) / float2(1024.0f,512.0f),
		float2(-1,-1) / float2(1024.0f,512.0f),
		float2( 0,-1) / float2(1024.0f,512.0f),
		float2( 1,-1) / float2(1024.0f,512.0f),
		float2( 1, 0) / float2(1024.0f,512.0f),
		float2( 1, 1) / float2(1024.0f,512.0f),
		float2( 0, 1) / float2(1024.0f,512.0f),
		float2(-1, 1) / float2(1024.0f,512.0f),
	};
	
	float4	diffuse_color 		= 	float4(solid_color_specular.xyz, 1.f);
	
	if( CONFIG_TDIFFUSE)
		diffuse_color			= 	t_base.Sample(s_base, tc);
	
	float4  base_diffuse_color  = diffuse_color;
	
	if( CONFIG_TNORMAL)
		normal					= psf_tnormal(t_normal, tangent_trans, tc, float3(1,1,1));
	float3 base_normal			= normal;
	float3 scaterring_color		= float3(0.15f,0.0f,0.0f);
	float3 base_lighting		= 0;
	float scatter = 0;
	float NdotL0 = 0;
	{
		float NdotL 		= ( dot(normal, -normalize(position - forward_light_position_and_range.xyz)) + 0.5f ) / (1.0f + 0.5f);
		NdotL0 = NdotL;
		float scatterWidth	= 0.4f;
		float wrap			= 0.2f;
		float NdotL_wrap	= max(0, (NdotL + wrap) / (1.0f + wrap));
		float fresnel		= 0.2*saturate(psf_fresnel(normal, normalize(-position), 2 ));
		scatter				= smoothstep(0.0, scatterWidth, NdotL_wrap) * smoothstep(scatterWidth * 2.0, scatterWidth, NdotL_wrap);
		
		scaterring_color   *= scatter;
		base_lighting		= base_diffuse_color.rgb * NdotL;
	}
	
	static const float blur_power0 = 1.0f;
	static const float blur_power1 = 1.0f;

	float3 blurred_diffuse      = 0;

	int i=0;
	UNROLL
	for (; i<num_samples; i++)
	{
		diffuse_color.gb	= 	t_base.Sample(s_base,				 tc + blur_power0 * 0*0.5*texture_space_offsets[i]).gb;
		diffuse_color.r		= 	t_base.Sample(s_base,				 tc + blur_power0 * 0*2.0*texture_space_offsets[i]).r;
		normal				= 	psf_tnormal(t_normal, tangent_trans, tc + blur_power0 * 0*0.25*texture_space_offsets[i], float3(1,1,1));
		float NdotL 		= ( dot(normal, -normalize(position - forward_light_position_and_range.xyz)) + 0.0f ) / (1.0f + 0.0f);
		blurred_diffuse    += diffuse_color.rgb;
	}
	blurred_diffuse /= num_samples;
	
	float3 blurred_diffuse_more      = 0;
	float3 blurred_diffuse_only_more      = 0;
	float3 blurred_diffuse_more2      = 0;
	float3 blurred_normal_more       = 0;
	
	UNROLL
	for (i=0; i<num_samples; i++)
	{
		diffuse_color.r		= 	t_base.Sample(s_base,				 tc + blur_power1 * 3.0*texture_space_offsets[i]).r * 0.8f;
		diffuse_color.g		= 	t_base.Sample(s_base,				 tc + blur_power1 * 2.0*texture_space_offsets[i]).g * 0.8f;
		diffuse_color.b		= 	t_base.Sample(s_base,				 tc + blur_power1 * 2.0*texture_space_offsets[i]).b * 0.8f;
		
		normal				= 	psf_tnormal(t_normal, tangent_trans, tc + blur_power1 * 3.0*texture_space_offsets[i], float3(1,1,1));
		float NdotL 		= ( dot(normal, -normalize(position - forward_light_position_and_range.xyz)) + 0.3f ) / (1.0f + 0.3f);
		blurred_diffuse_more    += pow(NdotL,1.0) * diffuse_color.rgb;
		blurred_diffuse_more2    += pow(NdotL,1.0);// * diffuse_color
		blurred_diffuse_only_more += diffuse_color.rgb;
		blurred_normal_more     += normal;
	}
	
	blurred_diffuse_only_more /= num_samples;
	blurred_diffuse_more /= num_samples;
	blurred_diffuse_more2 /= num_samples;
	blurred_normal_more  /= num_samples;
	
	float3  blurred_lighting		=   0;
	float3  blurred_lighting2		=   0;

	UNROLL
	for (i=0; i<num_samples; i++)
	{
		normal				= 	psf_tnormal(t_normal, tangent_trans, tc + 2*texture_space_offsets[i], float3(1,1,1));
		float NdotL 		= ( dot(normal, -normalize(position - forward_light_position_and_range.xyz)) + 0.5f ) / (1.0f + 0.5f);
		float NdotL2 		= ( dot(normal, -normalize(position - forward_light_position_and_range.xyz)) + 0.7f ) / (1.0f + 0.7f);
		blurred_lighting   += NdotL;
		blurred_lighting2   += NdotL2;
	}
	blurred_lighting /= num_samples;
	blurred_lighting2 /= num_samples;
	
	
	
	float3 light_vec    = position - forward_light_position_and_range.xyz;
	float3 light_dir	= -normalize(light_vec);
	float3 viewer 		=  -normalize(position);
	
	float3 reflection   = reflect( light_dir, base_normal);
	
	float RdotV			= max( -dot( reflection, viewer ), 0.0f );
	float specular		= specular_intensity * pow( RdotV, specular_power );
	final_color		   += base_diffuse_color.rgb * specular;
//	float light_attenuation 	= saturate	(1 - dot(light_vec,light_vec)*forward_light_position_and_range.w);	

	float square_distance	= squared_length( light_vec );
	float distance			= sqrt( square_distance );
	float attenuation		= 1;//saturate(dot( light_attenuation, float3(square_distance, distance, 1.f ) ));
	//return float4(pow(saturate(blurred_lighting2),2.5),1);
	
	float3  fresnel			  = 0.8*saturate(psf_fresnel(base_normal, viewer, 2 ));
	float3 skin_blood_scatter = float3(0.05f,0.0f,0.0f);// * pow(clamp(fresnel,0,0.7),1.5f);
	
	float3 NdotL_scatter2	  = saturate(dot(-light_dir,blurred_normal_more));
	float3 NdotL_scatter	  = pow(1-saturate(NdotL_scatter2 + saturate(dot(light_dir,blurred_normal_more))),2);
	
	float3 NdotV			  = pow(saturate(dot(base_normal, light_dir)),10);
	specular 				  = 0.1*pow(saturate(1-saturate(beckmann_specular(normal, light_dir, viewer, 1.2))),2.0f);
	//2*NdotV + specular;
	float3 fixed_specular	  = specular;
	
	float3 to_red = 1-2*blurred_lighting*(1-blurred_lighting);//pow(saturate(blurred_lighting),0.33);
	
	//float3 to_red_color = pow(saturate(t_skin_red.Sample(s_base, float2(0.5f, 0.5f+0.5*(1-to_red)))*3.5),2);
	float3 to_red_color = 1;//t_skin_red.Sample(s_base, float2(0.5f, 0.5f+0.5*(1-to_red)));
	
	final_color   = lerp(1.0*NdotL_scatter * skin_blood_scatter + blurred_diffuse_more, blurred_diffuse, pow(blurred_lighting,1.0));
	final_color  += specular_intensity*fixed_specular;
	float3 c = lerp(final_color,to_red_color,1-blurred_lighting);
	
	float3 back = pow( 1-saturate(blurred_diffuse_more),2);
	float3 back_color = lerp(float3(0,0,0), float3(93.0/255.0,58.0/255.0,40.0/255.0), back);
	
	float3 cc = 0.6*lerp(blurred_diffuse_only_more,blurred_diffuse,0.3) * saturate(blurred_diffuse_more2+blurred_diffuse_more+2*back_color);
	
	return float4(fixed_specular + blurred_diffuse_only_more * blurred_diffuse,1);//float4(specular_intensity*fixed_specular + lerp(cc,blurred_diffuse_more2*blurred_diffuse_only_more,0*NdotV),0);
	
	/*
	return float4( (blurred_diffuse_more2 + (blurred_diffuse_more+back_color)), 0);
	return float4((saturate(blurred_diffuse_more)) * (saturate(blurred_diffuse)),1);
	
	return float4(0*specular_intensity*fixed_specular + lerp(blurred_diffuse_more.rgb, blurred_diffuse.rgb, 0.0f),0);
	
	if (0)
		return float4(light_attenuation * base_lighting * forward_light_color + 0*NdotV * light_attenuation,1);
	else
		return float4(1*light_attenuation*blurred_lighting2*to_red_color + to_red_color*light_attenuation * final_color * forward_light_color + 0*light_attenuation * fresnel * blurred_diffuse_more,1);
		*/
}
