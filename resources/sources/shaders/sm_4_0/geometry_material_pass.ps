 ////////////////////////////////////////////////////////////////////////////
//	Created		: 13.07.2011
//	Author		: Nikolay Partas
//	Copyright (C) GSC Game World - 2011
////////////////////////////////////////////////////////////////////////////

/*	$DEFINES$:
		GLOBAL_ALLOW_STEEPPARALLAX,
		GLOBAL_FP16_BLEND,
		GLOBAL_GBUFFER_POS_PACKING,
		GLOBAL_GBUFFER_NORMAL_PACKING,
		GLOBAL_USE_BRANCHING,
		
		CONFIG_VERTEX_INPUT_TYPE,
		CONFIG_TDIFFUSE,
		CONFIG_TNORMAL,
		CONFIG_TDETAIL_NORMAL,
		CONFIG_PARALLAX,
		CONFIG_TSPECULAR_INTENSITY,
		CONFIG_TSPECULAR_POWER,
		CONFIG_TRANSLUCENCY,
		CONFIG_EMISSIVE,
		CONFIG_TFRESNEL_AT_0_DEGREE,
		CONFIG_TDETAIL,
		CONFIG_ALPHA_TEST,
		CONFIG_REFLECTION,
		CONFIG_REFLECTION_MASK,
		CONFIG_VARIATION_MASK,
		CONFIG_SEQUENCE,
*/
#include "common.h"
#include "spherical_harmonics_common.h"

#include "v2p_common.h"

#include "psf_diffuse.h"
#include "psf_alpha_test.h"
#include "psf_detail.h"
#include "psf_normal.h"
#include "psf_parallax.h"
#include "psf_translucent.h"
#include "psf_tspecular_intensity.h"
#include "psf_tspecular_power.h"
#include "psf_emissive.h"
#include "psf_make_tangent_transform.h"
#include "psf_reflection.h"
#include "psf_fresnel.h"
#include "psf_tc_modifiers.h"

#include "material.h"
#include "vertex_input.h"

#include "gamma_correction.h"

#if	CONFIG_EMISSIVE || (CONFIG_REFLECTION == 1)
#	define RT_EXTENTION_TARGET	1
#endif

#include "gbuffer.h"
#include "psf_emissive_write.h"

uniform float4 screen_res;

Texture2D t_translucency;
Texture2D t_specular_intensity;
Texture2D t_emission;
Texture2D t_height_map;
TextureCube t_cubemap;
Texture2D t_cubemap_mask;
Texture2D t_detail_normal;

float object_transparency_scale;

float4 packed_variation_mask_parameters;
static const float variation_position_devider = packed_variation_mask_parameters.x;
static const float variation_rotate = packed_variation_mask_parameters.y;
static const float variation_scale = packed_variation_mask_parameters.z;
static const float variation_multiply = packed_variation_mask_parameters.w;
float4 variation_color;
Texture2D t_variation_mask;

Texture2D  t_accumulator_dif;
Texture2D  t_accumulator_spec;
Texture2D  t_ssao_accumulator;

float4 far_fog_color_and_distance;
float near_fog_distance;
float4 ambient_color;


float4 environment_skylight_upper_color;
float4 environment_skylight_lower_color;
float4 environment_skylight_parameters;

float4 detail_normal_parameters;
static const float2 detail_normal_multiplier = detail_normal_parameters.xy;
static const float2 detail_normal_tile = detail_normal_parameters.zw;

float alpha_ref_parameter;

float3 specular_color_parameter;

float reflection_power;
float min_reflection_angle;
float4 specular_color_multiplier;

Texture3D t_radiance_r;
Texture3D t_radiance_g;
Texture3D t_radiance_b;

float2 constant_tile_uv;

// size xy, start frame, speed
float4 sequence_parameters;

void main(in vertex_output_struct input,
		  out float4 rt0: SV_Target0)
{
	material_parameters parameters 		= get_material_parameters(input);
	fill_material_parameters			(parameters);
	
	rt0 = (1.0f).xxxx;
	
#if 1	
	float3 final_color					= float3(0.0f, 0.0f, 0.0f);
	
	const float2 screen_uv				= input.homogeneous_position.xy / screen_res.xy;
	float2 								temp_value;
	gbuffer_read_rt_normal				(screen_uv, parameters.normal, temp_value.x, temp_value.y);
	
	float3 normal 						= parameters.normal;
	float2 tc							= parameters.tc * constant_tile_uv;
	
	if( CONFIG_SEQUENCE)
	{
		tc									= 	psf_calculate_sequence_tc(
													tc, 
													sequence_parameters.x, 
													sequence_parameters.y, 
													sequence_parameters.z, 
													sequence_parameters.w * scene_time
												);
	}
	
	if( CONFIG_PARALLAX)
		tc 								= psf_parallax(
			t_height_map, 
			parameters.world_view_position.xyz, 
			tc, 
			parameters.tangent_to_viewspace
		);
	
	float4	diffuse_color				= float4(convert_to_linear_space(solid_color_specular.xyz), 1.f);
	float4	texture_diffuse_color		= diffuse_color;
	
	if (CONFIG_TDIFFUSE)
		texture_diffuse_color			= t_base.Sample(s_base, tc);
	
	if (CONFIG_TDETAIL)
	{
		float4	detail_diffuse_color	= t_detail.Sample( s_detail, parameters.detail_tc);
		
		texture_diffuse_color.rgb		= lerp(
			texture_diffuse_color.rgb, 
			detail_diffuse_color.rgb, 
			detail_diffuse_color.a
		);
	}
	
	if (CONFIG_TDIFFUSE)
		diffuse_color					*= texture_diffuse_color;
	
	if( CONFIG_ALPHA_TEST)
	{
		float alpha						= t_base.SampleLevel(s_base, tc, 0).a;
		clip							(alpha - alpha_ref_parameter);
	}
	
	 // Translucency
	float3 	translucensy 				= solid_material_params.z;
	if (CONFIG_TRANSLUCENCY)
		translucensy 					*= psf_ttranslucency(t_translucency,  tc);
	
	float3 	specular_color 				= convert_to_linear_space(specular_color_parameter);
	if( CONFIG_TSPECULAR_INTENSITY)
		specular_color 					*= psf_tspecular_intensity(t_specular_intensity, tc);
	
	float3 	emission_color				= float3(0.0f, 0.0f, 0.0f);
	if ( CONFIG_EMISSIVE == 2)
		emission_color 					= psf_emissive(t_emission, tc, solid_emission_color.rgb);
	else
		if ( CONFIG_EMISSIVE == 1)
			emission_color				= solid_emission_color.rgb;
	
	float reflection_mask				= 1.0f;
	
	if (CONFIG_REFLECTION_MASK == 1)
	{
		reflection_mask					= t_cubemap_mask.Sample(s_base, tc).r;
	}

	if( CONFIG_VARIATION_MASK)
	{
		float3 world_position 			= mul(m_W, float4(0,0,1,1)).xyz;
		float2 world_xz_offset 			= world_position.xz / variation_position_devider;
		float2 new_tc 					= 
			world_xz_offset
			+
			psf_rotate_tc				(
				tc, 
				float2(0.5f, 0.5f), 
				variation_rotate
			) * variation_scale;
		
		float4 result_mask 	   			= t_variation_mask.Sample(s_base, new_tc) * variation_multiply;
		diffuse_color.rgb 				= lerp(
			diffuse_color.rgb, 
			variation_color.rgb, 
			variation_color.a * saturate(result_mask.x)
		);
	}
	
	diffuse_color.rgb					*= parameters.color.rgb;
	
	float4 decal_diffuse_and_alpha 		= t_decals_diffuse.Sample(s_diffuse, screen_uv);
	
//	uint inteter_alpha					= decal_diffuse_and_alpha.a * 255;
//	diffuse_color.rgb					= lerp(
//		diffuse_color.rgb * (1.0f - float(inteter_alpha >> 1) / 255.0f) + decal_diffuse_and_alpha.rgb,
//		diffuse_color.rgb * decal_diffuse_and_alpha.rgb,
//		inteter_alpha & 0x01
//	);
	diffuse_color.rgb					= diffuse_color.rgb * (1.0f - decal_diffuse_and_alpha.a) + decal_diffuse_and_alpha.rgb;
	
	const float back_lighting_factor	= t_accumulator_dif.Sample(s_accumulator, screen_uv).w;
	translucensy 						*= diffuse_color.rgb;
	
	const float ssao_result				= t_ssao_accumulator.Sample(s_base, screen_uv).x;
	const float3 accum_diffuse			= t_accumulator_dif.Sample(s_accumulator, screen_uv).rgb;
	const float3 accum_specular			= t_accumulator_spec.Sample(s_accumulator, screen_uv).rgb;
	const float3 ambient_material_color = float3(0.0f, 0.0f, 0.0f);
	
	float3 from_sky						= normalize(mul(m_V, float4(0.0f, -1.0f, 0.0f, 0.0f)).xyz);
	float3 from_ground					= normalize(mul(m_V, float4(0.0f, 1.0f, 0.0f, 0.0f)).xyz);
	
	float sky_dot_normal				= pow(dot(-from_sky, normal   ) * 0.5 + 0.5f, environment_skylight_parameters.x);
	float ground_dot_normal				= pow(dot(-from_ground, normal) * 0.5 + 0.5f, environment_skylight_parameters.y);
	
	float3 skylight_color				= float4(sky_dot_normal * environment_skylight_upper_color.a * convert_to_linear_space(environment_skylight_upper_color.rgb), 1.0f);
	skylight_color						+= float4(ground_dot_normal * environment_skylight_lower_color.a * convert_to_linear_space(environment_skylight_lower_color.rgb), 1.0f);
	
	float3 diffuse_before_reflection	= 
			diffuse_color.rgb 
			* 
			(
				accum_diffuse 
				+
				convert_to_linear_space( ambient_color.rgb )
				+
				skylight_color
				+
				0.0f * float3(0.8f, 0.8f, 0.8f)
				+
				convert_to_linear_space( ambient_material_color )
			);

	float3 final_diffuse			= diffuse_before_reflection;
	float3 final_specular			= accum_specular * specular_color;
	if(CONFIG_REFLECTION == 1)
	{
		float3 view_direction		= normalize( -parameters.world_view_position.xyz );
		float current_value			= 1.f - dot( view_direction, normal );
		float min_value				= 1.f - cos( min_reflection_angle );
		float base					= /*sqrt*/( ( min( max( current_value, min_value ), 1.f) - min_value)/(1.f - min_value) );
		float fresnel_factor		= pow( base, -5*log( reflection_power) );

		float3 reflection			= 
			reflection_mask *
			specular_color * 
			//float3(1,1,1)
			psf_reflection(
				float3(0,0,0), 
				t_cubemap, 
				normal, 
				parameters.world_view_position.xyz
			)
		;

		final_diffuse				= 
			lerp(
				diffuse_before_reflection,
				reflection,
				min( max( specular_color_multiplier.xyz * fresnel_factor * reflection_power, 0.f), 1.f)
			);

	}
	else if ( CONFIG_REFLECTION == 2)
	{
		final_diffuse				+= reflection_mask * specular_color * lerp(
			psf_reflection(
				float3(0,0,0), 
				t_cubemap, 
				normal, 
				parameters.world_view_position.xyz
			), 
			diffuse_before_reflection, 
			0.5
		);
	}
	
	final_color 						= 
		emission_color
		+ 
		ssao_result	* final_diffuse
		+ 
		final_specular
	;
	
	// Apply fog.
	final_color							= lerp(
		final_color,
		far_fog_color_and_distance.rgb,
		1.0f - saturate(
			exp(
				-(parameters.world_view_position.z - near_fog_distance) 
				/ 
				far_fog_color_and_distance.a
			)
		)
	);
	
	clip(parameters.color.a - 0.1f);
	
	final_color							+= back_lighting_factor * translucensy;
	
	rt0									= float4(final_color, parameters.color.a);
#endif // #if 0	
}