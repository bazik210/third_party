////////////////////////////////////////////////////////////////////////////
//	Created		: 06.09.2011
//	Author		: Nikolay Partas
//	Copyright (C) GSC Game World - 2011
////////////////////////////////////////////////////////////////////////////

/*
	$DEFINES$:
		GLOBAL_USE_LOOP_UNROLLING,
*/

#include "common.h"
#include "gbuffer.h"
#include "gamma_correction.h"


struct vertex_output_struct
{
	float4 position	: SV_POSITION;
	float2 uv		: TEXCOORD0;
};


Texture2D 	t_frame_color;

uniform float4 screen_res; // Screen resolution ( x-Width,y-Height, zw - 1/resolution)

float3 get_frame_color_point(float2 uv)
{
	return t_frame_color.Sample(s_accumulator, uv).rgb;
}

float3 get_frame_color_linear(float2 uv)
{
	return t_frame_color.Sample(s_base, uv).rgb;
}

// http://visual-computing.intel-research.net/publications/papers/2009/mlaa/mlaa.pdf
float4 main(vertex_output_struct input) : SV_TARGET
{
	float2 uv 					= input.uv;
	
	float3 frame_color 			= get_frame_color_linear(uv);
	float3 vb 					= get_frame_color_linear(uv + float2(1,0) * screen_res.zw) - 
								  get_frame_color_linear(uv + float2(-1,0) * screen_res.zw);
								
	float3 hb 					= get_frame_color_linear(uv + float2(0,1) * screen_res.zw) - 
								  get_frame_color_linear(uv + float2(0,-1) * screen_res.zw);
	
	float vg 					= dot(vb, float3(0.2126f, 0.7152f, 0.0722f));
	float hg 					= dot(hb, float3(0.2126f, 0.7152f, 0.0722f));
	
	float3 color 		 		= frame_color.rgb;
	float2 offset 		 		= float2(hg, -vg); 
	float  offset_length 		= length(offset);
	
	offset 						/= offset_length;
	
	color 						+= get_frame_color_linear(uv + offset * screen_res.zw) + 
								   get_frame_color_linear(uv - offset * screen_res.zw);
	
	color 						/= float3(3.0f, 3.0f, 3.0f);
	
	static const float threshold = 0.5f;
	
	float blend 				= offset_length / threshold;
	
	blend 						= min(blend, 1.0f);
	
	return float4(
		convert_from_linear_space(frame_color.rgb * (1.0f - blend) + color.rgb * blend), 
		0.0f
	);
}










