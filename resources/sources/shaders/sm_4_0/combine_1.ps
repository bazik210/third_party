#include "common.h"
#include "gbuffer.h"

uniform	sampler2D	s_float_depth;

#include "light.h"
#include "hmodel.h"
#include "light_ps_helper.h"
#include "gamma_correction.h"

Texture2D  t_emissive;
Texture2D  t_accumulator_dif;
Texture2D  t_accumulator_spec;
Texture2D  t_ssao_accumulator;

float4 far_fog_color_and_distance;
float near_fog_distance;

float4 ambient_color;

uniform float4 screen_res; // Screen resolution ( x-Width,y-Height, zw - 1/resolution)

static const float far_clip = near_far_invn_invf.y;

struct combine_input_struct
{
	float4 hpos     : SV_POSITION;
	float3 eye_ray	: TEXCOORD0;
	
#ifdef USE_VTF
	float4 tc0      : TEXCOORD1;    // tc.xy, tc.w = tonemap scale
#else
	float2 tc0      : TEXCOORD1;    // tc.xy
#endif
	float2 tcJ		: TEXCOORD2;	// jitter coords
};

struct combine_output_struct
{
	float4 low  	: SV_TARGET0;
	float4 high 	: SV_TARGET1;
};

uniform sampler1D         fog_table;

combine_output_struct main ( combine_input_struct input )
{
	float2 uv			= input.tc0;
	g_data gb 			= gbuffer_read(uv, input.eye_ray);
	float4 gb_emissive 	= t_emissive.Sample(s_position, uv );
	
	float ssao_result	= pow(t_ssao_accumulator.Sample( s_base, uv).x, 1.0f);
	
	float4 accum_diff   = t_accumulator_dif.Sample (s_accumulator, uv);  // diffuse.specular
	float4 accum_spec   = t_accumulator_spec.Sample(s_accumulator, uv);  // diffuse.specular
	
	//hemisphere
//	float3  hdiffuse,hspecular;
//	hmodel( hdiffuse, hspecular, 1.f, 0.5f/* -hemi- N.w*/, gb.specular_intensity, gb.position.xyz, gb.normal.xyz);
	
	// gamma correction: conversion from pc gamma space to linear space
	
	float3 gb_specular		= 1;
	
	// yellow satin
	//gb.diffuse			= convert_from_linear_space( float3( 0.0066f, 0.0022f, 0.0004f ) );
	//gb_specular			= convert_from_linear_space( float3( 0.0542f, 0.0345f, 0.0131f ) );
	
	// red velvet
	//gb.diffuse			= convert_from_linear_space( float3( 0.0048, 0.0005, 0.0000 ) );
	//gb_specular			= convert_from_linear_space( float3( 0.1938, 0.0333, 0.0267 ) );
	
	// brushed aluminium
	//gb.diffuse			= convert_from_linear_space( float3( 0.0036, 0.0034, 0.0026 ) );
	//gb_specular			= convert_from_linear_space( float3( 0.0115, 0.0105, 0.0075 ) );
	
	float3 diffuse	= (gb.diffuse) * (accum_diff.rgb * LIGHT_ACCUMULATOR_MAGNIFY_FACTOR + convert_to_linear_space(ambient_color.xyz) );
	float3 specular	= (gb_specular) * accum_spec.rgb * gb.specular_intensity * LIGHT_ACCUMULATOR_MAGNIFY_FACTOR;// + hspecular;
	float3 color	= diffuse.rgb + specular.rgb;// + (1.0f - gb_emissive.w) * gb_emissive.rgb * LIGHT_ACCUMULATOR_MAGNIFY_FACTOR;
	 
	color 				*= ssao_result;
	
	float3 far_fog 		= 1.0f - saturate( exp( -(gb.position.z - near_fog_distance) / (far_fog_color_and_distance.a) ) );
	color 				= lerp(color, far_fog_color_and_distance.rgb, far_fog);
	
	combine_output_struct output;
	
	output.low 			= float4(color, 0.0f);
	output.high 		= float4(color, 0.0f);
	
	return 				output;
}














