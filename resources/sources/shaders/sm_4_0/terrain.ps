/*	$DEFINES$: 
		GLOBAL_ALLOW_STEEPPARALLAX,
		GLOBAL_GBUFFER_POS_PACKING,
		GLOBAL_GBUFFER_NORMAL_PACKING,
		
		CONFIG_TNORMAL,
		CONFIG_PARALLAX,
*/

#include "common.h"
#include "gbuffer.h"

#include "v2p_common.h"

#include "psf_normal.h"
#include "psf_parallax.h"
#include "psf_make_tangent_transform.h"

#define V2P_PARAM_TC0			1

#if CONFIG_PARALLAX || CONFIG_TNORMAL
#	define V2P_PARAM_TANGENTS		1
#endif

#include "v2p_terrain.h"



uniform sampler       		s_array;
uniform Texture2DArray      t_array_diffuse;
uniform Texture2DArray      t_array_nmap;

Texture2D					t_height;
Texture2D					t_color;
Texture2D					t_params;
Texture2D					t_tex_ids;
Texture2D					t_tc_shift;

uniform float4				terrain_size;
uniform float4				start_corner;

g_struct main( v2p_terrain input ) 
{
	v2p_common		data;
	fill_v2p_common ( input, data );

	float2 tc 		= data.tc * terrain_size.zw; //float2( input.P.x - start_corner.x, -(input.P.z - start_corner.z)) * terrain_size.zw;
	float2 tc_shift	= t_tc_shift.Sample( s_rtlinear, tc).xy;
	tc_shift		= float2( -1.f, 1.f)*tc_shift*( (64.f*2.f) - 64.f);
	tc_shift		*= 	terrain_size.zw;

	float4 color	= t_color.Sample( s_rtlinear, tc);
	float4 params	= t_params.Sample( s_rtlinear, tc);
	float4 tex_ids	= t_tex_ids.Sample( s_rtlinear, tc);
	
	const float m = 255.f;
	float alpha0, alpha1, alpha2;
	alpha0 = params.x;
	alpha1 = params.y;
	alpha2 = params.z;


	float tex_ind0, tex_ind1, tex_ind2;
	tex_ind0 = tex_ids.x;
	tex_ind1 = tex_ids.y;
	tex_ind2 = tex_ids.z;

	float3 asd = float3( tex_ind0, tex_ind1, tex_ind2);
	const float tc_tiles = 8.f;
	
	float4 c0 = 	t_array_diffuse.Sample( s_array, float3( (tc + tc_shift)*tc_tiles, (asd.x*255.f))); 
	float4 c1 = 	t_array_diffuse.Sample( s_array, float3( (tc + tc_shift)*tc_tiles, (asd.y*255.f))); 
	float4 c2 = 	t_array_diffuse.Sample( s_array, float3( (tc + tc_shift)*tc_tiles, (asd.z*255.f))); 

	float3x3 tangent_trans = psf_make_tangent_transform( data.tbn_x, data.tbn_y, data.tbn_z);
	float3 n0 = 	psf_tnormal( t_array_nmap, tangent_trans, (tc + tc_shift)*tc_tiles, (asd.x*255.f)).xyz;
	float3 n1 = 	psf_tnormal( t_array_nmap, tangent_trans, (tc + tc_shift)*tc_tiles, (asd.y*255.f)).xyz;
	float3 n2 = 	psf_tnormal( t_array_nmap, tangent_trans, (tc + tc_shift)*tc_tiles, (asd.z*255.f)).xyz;
	
	float3 tex_c = (c0.rgb * alpha0 + c1.rgb * alpha1 + c2.rgb * alpha2);
		
	float a_grey = 1 - (alpha0 + alpha1 + alpha2);	
	
	float3 c =	(tex_c + (a_grey * 0.5)) * color.rgb * 2;

	float3 normal	= input.normal;
	if( CONFIG_TNORMAL)
		normal	= normalize( n0 * alpha0 + n1 * alpha1 + n2 * alpha2 + a_grey*float3( 0.f, 0.f, 1.f));
	
	g_struct	Out	= gbuffer_store ( data.position.xyz, 
											normal.xyz, 
											float4( c.rgb, 0.01f),
											0.f, 
											0.f, 
											255.f,
											30.f);
	return Out;
}