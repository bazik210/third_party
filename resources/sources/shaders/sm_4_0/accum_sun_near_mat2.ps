#include "common.h"
#include "light.h"
#include "shadow.h"
#include "gbuffer.h"
#include "light_accumulator.h"
#include "parallel_light.h"
#include "light_ps_helper.h"

light_accumulator 	main		( v2p_sun I ) : SV_TARGET
{
//  float4	_P	= t_position.Sample 	(s_position, 	I.Tex0);
//  float4 	_N	= t_normal.Sample 		(s_normal,   	I.Tex0);

//	float4 _P	= gbuffer_read_rt_position	( I.Tex0, I.eye_ray);
//	float4 _N	= gbuffer_read_rt_normal	( I.Tex0);

	g_data gb	= gbuffer_read	( I.Tex0, I.eye_ray);
	return
		get_light_accumulator(
			light_color,
			parallel_light( gb, I.Tex0 )
		);

//	// ----- light-model
//	float 	m;
//
//	m = 10.f;//
//	light_factors light 	= parallel_light ( gb, I.Tex0 );
//
//	// ----- shadow
////  	float4 	P4 	= float4	(_P.x,_P.y,_P.z,1.f);
////	float4 	PS	= mul		(m_shadow0,	P4);
////	float 	s 	= sunmask	(P4);
//	#ifdef 	USE_SJITTER
////	  s 	*= shadowtest_sun 	(PS,tcJ);
//	#else
////	  s 	*= shadow		(PS);
//	#endif
//	
//	float s=1;
//	
////	float4 _P1	= gbuffer_read_rt_position	( I.Tex0+sin(I.Tex0+sin(I.Tex0)), I.eye_ray);
////	float4 _N1	= gbuffer_read_rt_normal	( I.Tex0+sin(I.Tex0+cos(I.Tex0)));
//
//	float4 _N = float4( gb.normal, 1.f); 
//	float4 _P = float4( gb.position, 1.f); 
//
//	float4 fake = saturate(float4(0.9,0,0,0.9) + 0.01*(sqrt(_P)+sqrt(_N)+sin(_P)+sin(_N)+ pow(_P,_P.x)+ pow(_N,_N.x)));
//
//	
//	light_accumulator result;
//	result.diffuse = float4( fake.rgb * light_color.rgb * light.x * s / LIGHT_ACCUMULATOR_MAGNIFY_FACTOR, 0);
//	result.specular = float4( fake.rgb * light_color.rgb * light.y * s / LIGHT_ACCUMULATOR_MAGNIFY_FACTOR, 0);
//	return result;
	
	//return 		blend		( fake*light_color * light * s, I.Tex0);
}
