////////////////////////////////////////////////////////////////////////////
//	Created		: 15.07.2011
//	Author		: Nikolay Partas
//	Copyright (C) GSC Game World - 2011
////////////////////////////////////////////////////////////////////////////

/*	$DEFINES$: 
		GLOBAL_ALLOW_STEEPPARALLAX,
		GLOBAL_GBUFFER_POS_PACKING,
		GLOBAL_GBUFFER_NORMAL_PACKING,
		
		CONFIG_VERTEX_INPUT_TYPE,
		CONFIG_TNORMAL,
		CONFIG_PARALLAX,
*/

#include "common.h"
#include "gbuffer.h"

#include "v2p_common.h"

#include "psf_normal.h"
#include "psf_parallax.h"
#include "psf_make_tangent_transform.h"

#define V2P_PARAM_TC0			1

#if CONFIG_PARALLAX || CONFIG_TNORMAL
#	define V2P_PARAM_TANGENTS		1
#endif

#include "v2p_terrain.h"



uniform sampler       		s_array;
uniform Texture2DArray      t_array_diffuse;
uniform Texture2DArray      t_array_nmap;
uniform Texture2DArray      t_array_spec;

Texture2D					t_height;
Texture2D					t_color;
Texture2D					t_params;
Texture2D					t_tex_ids;
Texture2D					t_tc_shift;


Texture2D					t_diffuse_detail;
Texture2D					t_normal_detail;

uniform float4				terrain_size;
uniform float4				start_corner;

void	main(in v2p_terrain input,
			 out float4 out_depth_render_target			: SV_Target0,
			 out float4 out_normals_render_target		: SV_Target1,
			 out float4 out_tangents_render_target		: SV_Target2)
{
	v2p_common		data;
	fill_v2p_common ( input, data );

	float2 tc 		= data.tc * terrain_size.zw; //float2( input.P.x - start_corner.x, -(input.P.z - start_corner.z)) * terrain_size.zw;
	float2 tc_shift	= t_tc_shift.Sample( s_rtlinear, tc).xy;
	tc_shift		= float2( -1.f, 1.f)*tc_shift*( (64.f*2.f) - 64.f);
	tc_shift		*= 	terrain_size.zw;

	float4 color	= t_color.Sample( s_rtlinear, tc);
	float4 params	= t_params.Sample( s_rtlinear, tc);
	float4 tex_ids	= t_tex_ids.Sample( s_rtlinear, tc);
	
	const float m = 255.f;
	float alpha0, alpha1, alpha2;
	alpha0 = params.x;
	alpha1 = params.y;
	alpha2 = params.z;
	
	float tex_ind0, tex_ind1, tex_ind2;
	tex_ind0 = tex_ids.x;
	tex_ind1 = tex_ids.y;
	tex_ind2 = tex_ids.z;
	
	float3 asd = float3( tex_ind0, tex_ind1, tex_ind2);
	const float tc_tiles = 8.f;
	
	float4 diffse_detail =	t_diffuse_detail.Sample( s_array, (tc + tc_shift) * tc_tiles * 10.0f);
	
	float3x3 tangent_trans = psf_make_tangent_transform( data.tbn_x, data.tbn_y, data.tbn_z);
	float3 n0 = 	psf_tnormal( t_array_nmap, (tc + tc_shift)*tc_tiles, (asd.x*255.f), float3(1,1,1)).xyz;
	float3 n1 = 	psf_tnormal( t_array_nmap, (tc + tc_shift)*tc_tiles, (asd.y*255.f), float3(1,1,1)).xyz;
	float3 n2 = 	psf_tnormal( t_array_nmap, (tc + tc_shift)*tc_tiles, (asd.z*255.f), float3(1,1,1)).xyz;
	
	//float3 normal_detail =	psf_tnormal(t_normal_detail, (tc + tc_shift) * tc_tiles * 10.0f, float3(1,1,1)).xyz;
	
	float a_grey  = 1 - (alpha0 + alpha1 + alpha2);	
	
	float3 normal = input.normal;
	
	if( CONFIG_TNORMAL)
		normal	= normalize( n0 * alpha0 + n1 * alpha1 + n2 * alpha2 + a_grey*float3( 0.f, 0.f, 1.f));
	
	normal = normalize(mul( tangent_trans, normal));
	
	float3 tangent						= float3(0.f, 1.f, 0.f);
	float2 packed_tangent				= normal.x != 0.f ? tangent.yz : (normal.y != 0.f ? tangent.xz : tangent.xy);
	
	float fresnel_at_0_degree_value 	= 1.0f;
	float alpha_model_parameter_value	= 0.0f;
	
	//float packed_fresnel_at_0_degree_and_specular_power
	//	= (256.0f * floor(fresnel_at_0_degree_value) + floor(20.f/255.f)) * 1.0f / 65535.0f;
	
	out_depth_render_target				= float4(
		sqrt(data.position.z * near_far_invn_invf.w), 
		0.0f,
		(50.0f / 255.0f).xx
	);
	
	out_normals_render_target			= float4(
		normal.xy * 0.5f + 0.5f, 
		0.075f,
		normal.z > 0 ? 0 : 1
	);
	
	out_tangents_render_target			= float4(normalize(tangent_trans[0]) * 0.5f + 0.5f, 1.0f);
}
