////////////////////////////////////////////////////////////////////////////
//	Created		: 28.12.2010
//	Author		: Nikolay Partas
//	Copyright (C) GSC Game World - 2010
////////////////////////////////////////////////////////////////////////////

/*
	$DEFINES$:
		GLOBAL_USE_LOOP_UNROLLING,
*/

#include "common.h"
#include "gbuffer.h"

Texture2D 	t_frame_color;

uniform float4 screen_res; // Screen resolution ( x-Width,y-Height, zw - 1/resolution)

#define USE_ANTIALIASING 				1
#	define USE_COLOR_EDGE_DETECTION 	1
#		define USE_MLAA 				1


float3 get_frame_color_point(float2 uv)
{
	return t_frame_color.Sample(s_accumulator, uv).rgb;
}

float3 get_frame_color_linear(float2 uv)
{
	return t_frame_color.Sample(s_base, uv).rgb;
}

float4 main( v2p_post_process input) : SV_TARGET
{
	float2 uv = input.uv;

	static const float2 offsets[8] = 
	{
		float2( 1.0f,  1.0f),
		float2( 1.0f,  0.0f),
		float2( 1.0f, -1.0f),
		float2( 0.0f,  1.0f),
		float2( 0.0f, -1.0f), 
		float2(-1.0f,  1.0f),
		float2(-1.0f,  0.0f),
		float2(-1.0f, -1.0f)
	};	
	

#if !USE_ANTIALIASING
	return float4(t_frame_color.Sample(s_accumulator, uv).rgb, 0);
#else

		
#if !USE_COLOR_EDGE_DETECTION	

	static const float depth_uv_scale = 1.0f;
	static const float normal_clip_max = 0.8f;
	static const float depth_max = 1.0f;
	static const float depth_inc = 2.0f;
	
	float frame_depth   = gbuffer_read_frame_depth(uv);
	float3 frame_normal = gbuffer_read_frame_normal(uv);

	float depth_difference = 0.0f; 
	
	if ( abs(gbuffer_read_frame_depth(uv + depth_uv_scale * offsets[3] * screen_res.zw) - frame_depth) > depth_max )  depth_difference += depth_inc; 
	if ( abs(gbuffer_read_frame_depth(uv + depth_uv_scale * offsets[1] * screen_res.zw) - frame_depth) > depth_max )  depth_difference += depth_inc; 
	if ( abs(gbuffer_read_frame_depth(uv + depth_uv_scale * offsets[6] * screen_res.zw) - frame_depth) > depth_max )  depth_difference += depth_inc; 
	if ( abs(gbuffer_read_frame_depth(uv + depth_uv_scale * offsets[4] * screen_res.zw) - frame_depth) > depth_max )  depth_difference += depth_inc; 
	
	float normal_accum 	   = 0.0f;
	//return depth_difference;
	
	static const float normal_uv_scale = 1.0f;
	
	normal_accum += (dot(frame_normal, gbuffer_read_frame_normal(uv + offsets[3] * screen_res.zw / normal_uv_scale)));
	normal_accum += (dot(frame_normal, gbuffer_read_frame_normal(uv + offsets[1] * screen_res.zw / normal_uv_scale)));
	normal_accum += (dot(frame_normal, gbuffer_read_frame_normal(uv + offsets[6] * screen_res.zw / normal_uv_scale)));
	normal_accum += (dot(frame_normal, gbuffer_read_frame_normal(uv + offsets[4] * screen_res.zw / normal_uv_scale)));
	normal_accum *= 0.25f;
	
	normal_accum = (normal_accum < normal_clip_max) ? 0.0f : normal_accum;
	
	float dz = abs(gbuffer_read_frame_depth(uv - float2(1, 0) * screen_res.zw) - gbuffer_read_frame_depth(uv + float2(1, 0) * screen_res.zw)) + 
			   abs(gbuffer_read_frame_depth(uv - float2(0, 1) * screen_res.zw) - gbuffer_read_frame_depth(uv + float2(0, 1) * screen_res.zw));
	
	
	/*
	float dn = length(gbuffer_read_frame_normal(uv - float2(1, 0) * screen_res.zw) - gbuffer_read_frame_normal(uv + float2(1, 0) * screen_res.zw)) + 
			   length(gbuffer_read_frame_normal(uv - float2(0, 1) * screen_res.zw) - gbuffer_read_frame_normal(uv + float2(0, 1) * screen_res.zw));
	
	float a = clamp(0.5*(dz+dn),0,1);
	*/
	float a = clamp(0.5*(dz),0,1);
	float3 clr = t_frame_color.Sample(s_accumulator, uv + float2(a, 0) * screen_res.zw).rgb + 
				 t_frame_color.Sample(s_accumulator, uv - float2(a, 0) * screen_res.zw).rgb +
				 t_frame_color.Sample(s_accumulator, uv + float2(0, a) * screen_res.zw).rgb +
				 t_frame_color.Sample(s_accumulator, uv - float2(0, a) * screen_res.zw).rgb;
	
	bool do_blur = normal_accum < 0.5 || depth_difference > 1.0f;
	
	//return do_blur;
	
	if (do_blur)
	{
		float3 average_frame_color = t_frame_color.Sample(s_accumulator, uv).rgb;
		
		UNROLL
		for (int i=0; i<8; i++)
		{
			average_frame_color += t_frame_color.Sample(s_accumulator, uv + offsets[i] * screen_res.zw).rgb;
		}
		return float4(average_frame_color / 9.0f, 0.0f);
	}
	else
	{
		return float4(t_frame_color.Sample(s_accumulator, uv).rgb, 0.0f);
	}

#elif USE_MLAA
	// http://visual-computing.intel-research.net/publications/papers/2009/mlaa/mlaa.pdf

	float3 frame_color = get_frame_color_linear(uv);
	float3 vb = get_frame_color_linear(uv + float2(1,0) * screen_res.zw) - get_frame_color_linear(uv + float2(-1,0) * screen_res.zw);
	float3 hb = get_frame_color_linear(uv + float2(0,1) * screen_res.zw) - get_frame_color_linear(uv + float2(0,-1) * screen_res.zw);
	
	float vg = dot(vb, float3(0.2126f, 0.7152f, 0.0722f));
	float hg = dot(hb, float3(0.2126f, 0.7152f, 0.0722f));
	
	float3 color 		 = frame_color.rgb;
	float2 offset 		 = float2(hg, -vg); 
	float  offset_length = length(offset);
	
	offset /= offset_length;
	
	color += get_frame_color_linear(uv + offset * screen_res.zw) + get_frame_color_linear(uv - offset * screen_res.zw);
	
	color /= float3(3.0f, 3.0f, 3.0f);
	
	static const float threshold = 0.5f;
	
	float blend = offset_length / threshold;
	
	blend = min(blend, 1.0f);
	
	//return blend;
	
	return float4(frame_color.rgb * (1.0f - blend) + color.rgb * blend, 0.0f);
	
#else // #elif USE_MLAA
	
	float uv_scale 	    = 1.0f;
    
	float frame_color_lum	= saturate(get_color_luminance(t_frame_color.Sample(s_accumulator, uv).xyz));
	
	float top_lum 		= get_color_luminance(t_frame_color.Sample(s_accumulator, uv + float2(0.0, -1.0) * uv_scale / screen_res).xyz);
	float left_lum 		= get_color_luminance(t_frame_color.Sample(s_accumulator, uv + float2(-1.0, 0.0) * uv_scale / screen_res).xyz);
	float right_lum 	= get_color_luminance(t_frame_color.Sample(s_accumulator, uv + float2(1.0, 0.0)  * uv_scale / screen_res).xyz);
	float bottom_lum 	= get_color_luminance(t_frame_color.Sample(s_accumulator, uv + float2(0.0, 1.0)  * uv_scale / screen_res).xyz);
	
    float2  normal 			= float2(-(top_lum - bottom_lum), right_lum - left_lum);
    float   normal_length 	= length(normal);
	
	normal_length = pow(normal_length, 1.0f);
	
    if (normal_length >= 1.0f / 16.0f)
    {
		normal *= (1.0f / screen_res) / normal_length;
		
		float4	o = t_frame_color.Sample(s_accumulator, uv),
				t0 = t_frame_color.Sample(s_accumulator, uv + normal  * 0.75f) * 0.9f,
				t1 = t_frame_color.Sample(s_accumulator, uv - normal  * 0.75f) * 0.9f,
				t2 = t_frame_color.Sample(s_accumulator, uv + normal) * 0.75f,
				t3 = t_frame_color.Sample(s_accumulator, uv - normal) * 0.75f;
		
		float o_lum = get_color_luminance(o.rgb);
		
		float d2 = saturate(o_lum - get_color_luminance(t0.rgb));
		float d3 = saturate(o_lum - get_color_luminance(t1.rgb));
		
		return (o + t0 + t1 + t2 + t3) / 4.3f;
		
		float4 res  = t_frame_color.Sample(s_accumulator, uv);
			   res += t_frame_color.Sample(s_accumulator, uv + normal);
			   res += t_frame_color.Sample(s_accumulator, uv - normal);
		
		return res / 3.0f;
    }
	else
	{
		return t_frame_color.Sample(s_accumulator, uv);	
	}
#endif

#endif // #if !USE_ANTIALIASING
}










