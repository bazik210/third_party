/*	$DEFINES$:
		GLOBAL_ALLOW_STEEPPARALLAX,
		GLOBAL_FP16_BLEND,
		GLOBAL_GBUFFER_POS_PACKING,
		GLOBAL_GBUFFER_NORMAL_PACKING,
		GLOBAL_USE_BRANCHING,
		
		CONFIG_VERTEX_INPUT_TYPE,
		CONFIG_TDIFFUSE,
		CONFIG_TNORMAL,
		CONFIG_TDETAIL_NORMAL,
		CONFIG_PARALLAX,
		CONFIG_TSPECULAR_INTENSITY,
		CONFIG_TSPECULAR_POWER,
		CONFIG_TDIFFUSE_POWER,
		CONFIG_TRANSLUCENCY,
		CONFIG_EMISSIVE,
		CONFIG_TFRESNEL_AT_0_DEGREE,
		CONFIG_TDETAIL,
		CONFIG_ALPHA_TEST,
		CONFIG_REFLECTION,
		CONFIG_VARIATION_MASK,
*/
#include "common.h"
#include "v2p_common.h"

#include "psf_diffuse.h"
#include "psf_alpha_test.h"
#include "psf_detail.h"
#include "psf_normal.h"
#include "psf_parallax.h"
#include "psf_translucent.h"
#include "psf_tspecular_intensity.h"
#include "psf_tspecular_power.h"
#include "psf_tdiffuse_power.h"
#include "psf_emissive.h"
#include "psf_make_tangent_transform.h"
#include "psf_reflection.h"
#include "psf_fresnel.h"
#include "psf_tc_modifiers.h"

#include "material.h"
#include "vertex_input.h"


#if	CONFIG_EMISSIVE || (CONFIG_REFLECTION == 1)
#	define RT_EXTENTION_TARGET	1
#endif

#include "gbuffer.h"
#include "psf_emissive_write.h"

uniform float4 screen_res;

Texture2D t_translucency;
Texture2D t_specular_intensity;
Texture2D t_specular_power;
Texture2D t_diffuse_power;
Texture2D t_emission;
Texture2D t_height_map;
Texture2D t_fresnel_at_0_degree;

Texture2D t_detail_normal;

TextureCube t_cubemap;

float object_transparency_scale;

float4 packed_variation_mask_parameters;
static const float variation_position_devider = packed_variation_mask_parameters.x;
static const float variation_rotate = packed_variation_mask_parameters.y;
static const float variation_scale = packed_variation_mask_parameters.z;
static const float variation_multiply = packed_variation_mask_parameters.w;
float4 variation_color;
Texture2D t_variation_mask;

float4 detail_normal_parameters;
static const float2 detail_normal_multiplier = detail_normal_parameters.xy;
static const float2 detail_normal_tile = detail_normal_parameters.zw;


g_struct 	main			(in vertex_output_struct input)
{
	material_parameters parameters = get_material_parameters(input);
	fill_material_parameters(parameters);
	
	float3	 	normal 			= 	parameters.normal;
	float2 		tc				= 	parameters.tc;
	
	if( CONFIG_PARALLAX)
		tc 						= 	psf_parallax		( t_height_map, parameters.world_view_position.xyz, tc, parameters.tangent_to_viewspace);
	
	float4	D 					= 	float4 ( solid_color_specular.xyz, 1.f);
	if( CONFIG_TDIFFUSE)
		D						*= 	t_base.Sample	( s_base, tc);
	
	/*
	float4 ShaderAAPS_SM3( SceneVS_Output Input, float2 ScrPos : VPOS ) : COLOR
	{
		float2 scrTexCrd = (ScrPos + 0.5) * pixelSize;

		float2 scrTexCrd_cent = Input.PosPS_cent.xy / Input.PosPS.w;
		scrTexCrd_cent = scrTexCrd_cent + 0.5 + pixelSize * 0.5;

		// move the texcoord "insidewards" 1 texel
		float2 crd = normalize(float3(scrTexCrd_cent - scrTexCrd, 0.0001)).xy * pixelSize + scrTexCrd;
		return tex2D(sampColor, crd);
	}
	*/
	
	//const float2 pixelSize = 1.0f / screen_res.xy;
	//float2 scrTexCrd = (ScrPos + 0.5) * pixelSize;
	//float2 scrTexCrd_cent = hposition.xy / hposition.w;
	//scrTexCrd_cent = scrTexCrd_cent + 0.5 + pixelSize * 0.5;	
	// move the texcoord "insidewards" 1 texel
	//float2 crd = normalize(float3(scrTexCrd_cent - scrTexCrd, 0.0001)).xy * pixelSize + scrTexCrd;
	//return tex2D(sampColor, crd);
	
	// Alpha test
	if( CONFIG_ALPHA_TEST)
	{
		// TODO: come up with a better solution
		float alpha				= 	t_base.SampleLevel	( s_base, tc, 0).a;
		clip(alpha - 0.4f);
		//psf_alpha_test			( alpha);
	}
	
	/*	
	float3 eye_view = mul(m_V, float4(eye_position.xyz, 1.0f));
	
	float alpha = saturate(30.0f / distance(parameters.world_view_position.xyz, eye_view));
	//D.rgb = alpha;
	//if (alpha>0.1)
	{
		float devider = 2.0f - saturate(alpha);
		float2 mask = float2( hposition.x/devider, hposition.y/devider);
		clip( frac(mask.x) - 1.0f / 2.0f);
		clip( frac(mask.y) - 1.0f / 2.0f);			
	}*/
	
	// Diffise detail mapping
	//if( CONFIG_TDETAIL)
	//	D.rgb					= 	psf_tdetail( t_detail, D.rgb, tc);
	
	if( CONFIG_TNORMAL)
	{
		if (CONFIG_TDETAIL_NORMAL)
		{
			// TODO: add special functions for normal map reading!!!
			float2 tiled_tc			= 	parameters.tc * detail_normal_parameters.zw;
			float3 normal_details	= 	float3(detail_normal_parameters.xy * (t_detail_normal.Sample(s_nofilter, tiled_tc).wy * 2.0f - 1.0f), 0.0f);
			normal_details.y 		 = -normal_details.y;
			
			normal					= 	psf_tnormal_detailed( t_normal, normal_details, parameters.tangent_to_viewspace, tc);
		}
		else
		{
			normal					= 	psf_tnormal( t_normal, parameters.tangent_to_viewspace, tc, float3(1,1,1));
		}
	}
	else
		normal					= 	normalize( mul( parameters.tangent_to_viewspace, float3(0.0f,0.0f,1.0f)) );

	
	 // Translucency
	float 	translucensy 		=	solid_material_params.z;
	if( CONFIG_TRANSLUCENCY)
		translucensy 			= 	psf_ttranslucency( t_translucency,  tc).x;
	
	float3 	specular_intensity 	= 	solid_color_specular.w;
	if( CONFIG_TSPECULAR_INTENSITY)
		specular_intensity 		= 	psf_tspecular_intensity( t_specular_intensity, tc);
	
	float 	specular_power 		= 	solid_material_params.x;//255.01;
	if( CONFIG_TSPECULAR_POWER)
		specular_power 			= 	psf_tspecular_power( t_specular_power, tc);
	
	float 	diffuse_power 		= 	solid_material_params.y;
	if( CONFIG_TDIFFUSE_POWER)
		diffuse_power 			= 	psf_tdiffuse_power( t_diffuse_power, tc);
	
	float3 	emmision_color		= 	float3( 0, 0, 0);
	if ( CONFIG_EMISSIVE == 2)
		emmision_color 			= 	psf_emissive( t_emission, tc, solid_emission_color.rgb);
	else
		if ( CONFIG_EMISSIVE == 1)
			emmision_color		= 	solid_emission_color.rgb;
	
	if( CONFIG_REFLECTION == 1)
		emmision_color			+=	specular_intensity * psf_reflection( float3(0,0,0), t_cubemap, normal, parameters.world_view_position.xyz);
	else if ( CONFIG_REFLECTION == 2)
		D.rgb					+=	specular_intensity * lerp( psf_reflection( float3(0,0,0), t_cubemap, normal, parameters.world_view_position.xyz), D.rgb, 0.5);
	
	diffuse_power 				*= object_transparency_scale;
	diffuse_power 				*= parameters.color.a;
	
	BRANCH
	if ( diffuse_power < 245.0f && frac(hposition.y * 0.5f) < 0.5 )
		clip(-1);
	
	BRANCH
	if (diffuse_power<10)
		clip(-1);
		
	if( CONFIG_VARIATION_MASK)
	{
		float3 world_position  = mul(m_W, float4(0,0,1,1)).xyz;
		float2 world_xz_offset = world_position.xz / variation_position_devider;
		
		float2 new_tc = 
			world_xz_offset
			+
			psf_rotate_tc(
				tc, 
				float2(0.5f, 0.5f), 
				variation_rotate
			) * variation_scale;
		
		float4 result_mask 	   = t_variation_mask.Sample(s_base, new_tc) * variation_multiply;
		
		D.rgb 				   = lerp(D.rgb, variation_color.rgb, variation_color.a * saturate(result_mask.x));
	}
	
	D.rgb						*= parameters.color.rgb;
	
	g_struct O					= gbuffer_store ( parameters.world_view_position.xyz, normal.xyz, float4( D.xyz, specular_intensity.r), solid_material_params.w, translucensy, diffuse_power, specular_power);
//	if ( CONFIG_EMISSIVE || CONFIG_REFLECTION == 1)
//		psf_emissive_write( emmision_color, O);
//	
	float3 tangent	= normalize( transpose(parameters.tangent_to_viewspace)[1] )*0.5 + 0.5;
	O.emissive.r	= fresnel_at_0_degree;
	O.emissive.g	= alpha_model_parameter;
	O.emissive.ba	= normal.x != 0.f ? float2(tangent.y, tangent.z) : (normal.y != 0.f ? float2(tangent.x, tangent.z) : float2(tangent.x, tangent.y));
	
#if CONFIG_TFRESNEL_AT_0_DEGREE
		O.emissive.r = t_fresnel_at_0_degree.Sample(s_base, tc).x;
#endif // #if CONFIG_TFRESNEL_AT_0_DEGREE

	return O;
}
