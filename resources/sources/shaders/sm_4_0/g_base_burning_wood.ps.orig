/*	$DEFINES$:
		GLOBAL_ALLOW_STEEPPARALLAX,
		GLOBAL_FP16_BLEND,
		GLOBAL_GBUFFER_POS_PACKING,
		GLOBAL_GBUFFER_NORMAL_PACKING,
		GLOBAL_USE_BRANCHING,

		CONFIG_TDIFFUSE,
		CONFIG_TNORMAL,
		CONFIG_PARALLAX,
		CONFIG_TRANSLUCENCY,
		CONFIG_TSPECULAR_INTENSITY,
		CONFIG_TSPECULAR_POWER,
		CONFIG_TDIFFUSE_POWER,
		CONFIG_TRANSLUCENCY,
		CONFIG_EMISSIVE,
		CONFIG_TFRESNEL_AT_0_DEGREE,
		CONFIG_TDETAIL,
		CONFIG_ALPHA_TEST,
		CONFIG_REFLECTION,
*/
#include "common.h"
#include "v2p_common.h"

#include "psf_diffuse.h"
#include "psf_alpha_test.h"
#include "psf_detail.h"
#include "psf_normal.h"
#include "psf_parallax.h"
#include "psf_translucent.h"
#include "psf_tspecular_intensity.h"
#include "psf_tspecular_power.h"
#include "psf_tdiffuse_power.h"
#include "psf_emissive.h"
#include "psf_make_tangent_transform.h"
#include "psf_reflection.h"
#include "psf_fresnel.h"
#include "psf_tc_modifiers.h"

#include "material.h"
#include "vertex_input.h"


#if	CONFIG_EMISSIVE || (CONFIG_REFLECTION == 1)
#	define RT_EXTENTION_TARGET	1
#endif

#include "gbuffer.h"
#include "psf_emissive_write.h"

Texture2D t_translucency;
Texture2D t_specular_intensity;
Texture2D t_specular_power;
Texture2D t_diffuse_power;
Texture2D t_emission;
Texture2D t_height_map;

Texture2D t_whirl;

TextureCube t_cubemap;

g_struct 	main			( in vertex_output_struct input,
							  in float4	hposition: SV_Position)
{
	material_parameters parameters = get_material_parameters(input);
	fill_material_parameters(parameters);

	float3	 	normal 			= 	parameters.normal;
	float2 		tc				= 	0.f;
	tc							= 	parameters.tc;
	
	if( CONFIG_PARALLAX)
		tc 						= 	psf_parallax		( t_height_map, parameters.world_view_position.xyz, tc, parameters.tangent_to_viewspace);
	
	float4	D 					= 	float4 ( solid_color_specular.xyz, 1.f);
	if( CONFIG_TDIFFUSE)
		D						= 	t_base.Sample	( s_base, tc);
	 
	// Alpha test
	if( CONFIG_ALPHA_TEST)
	{
		// TODO: come up with a better solution
		float alpha				= 	t_base.SampleLevel	( s_base, tc, 0).a;
		psf_alpha_test			( alpha);
	}
	
	// Diffise detail mapping
	if( CONFIG_TDETAIL)
		D.rgb					= 	psf_tdetail( t_detail, D.rgb, tc);
	
	if( CONFIG_TNORMAL)
		normal					= 	psf_tnormal( t_normal, parameters.tangent_to_viewspace, tc, float3(1,1,1));
	else
		normal					= 	normalize( mul( parameters.tangent_to_viewspace, float3(0.0f,0.0f,1.0f)) );
	
	 // Translucency
	float 	translucensy 		=	solid_material_params.z;
	if( CONFIG_TRANSLUCENCY)
		translucensy 			= 	psf_ttranslucency( t_translucency,  tc);
	
	float3	specular_intensity 	= 	solid_color_specular.w;
	if( CONFIG_TSPECULAR_INTENSITY)
		specular_intensity 		= 	psf_tspecular_intensity( t_specular_intensity, tc);
	
	float 	specular_power 		= 	solid_material_params.x;
	if( CONFIG_TSPECULAR_POWER)
		specular_power 			= 	psf_tspecular_power( t_specular_power, tc);
	
	float 	diffuse_power 		= 	solid_material_params.y;
	if( CONFIG_TDIFFUSE_POWER)
		diffuse_power 			= 	psf_tdiffuse_power( t_diffuse_power, tc);
	
	float3 	emmision_color		= 	float3( 0, 0, 0);
	if ( CONFIG_EMISSIVE == 2)
		emmision_color 			= 	psf_emissive( t_emission, tc, solid_emission_color.rgb);
	else
		if ( CONFIG_EMISSIVE == 1)
			emmision_color		= 	solid_emission_color.rgb;
	
	if( CONFIG_REFLECTION == 1)
		emmision_color			+=	specular_intensity * psf_reflection( float3(0,0,0), t_cubemap, normal, parameters.world_view_position.xyz);
	else if ( CONFIG_REFLECTION == 2)
		D.rgb					+=	specular_intensity * lerp( psf_reflection( float3(0,0,0), t_cubemap, normal, parameters.world_view_position.xyz), D.rgb, 0.5);
	
	D.rgb		*= parameters.color.rgb;
	
	g_struct O		= gbuffer_store ( parameters.world_view_position.xyz, normal.xyz, float4( D.xyz, specular_intensity.x), solid_material_params.w, translucensy, diffuse_power, specular_power);
	
//	if ( CONFIG_DIFFUSE_ATTENUATION)
//	{
//#if RT_EXTENTION_TARGET
//		O.emissive.rgb = solid_diffuse_attenuation_color.rgb * 0.25f;
//		O.emissive.a   = 1.0f;
//#endif	
//	}
	
	float a 			= (sin(scene_time * 2.0f) * 0.5f + 0.5f) * 35.0f;
	float4 whirl_color 	= 20.0f + a * t_whirl.Sample(s_base, psf_move_tc(parameters.tc, scene_time * float2(0.015f, 0.012f)));
	
	float4 whirl_color0 = t_whirl.Sample(s_base, psf_move_tc(parameters.tc, scene_time * float2(0.005f, 0.015f)));
	float4 whirl_color1 = t_whirl.Sample(s_base, psf_move_tc(parameters.tc, scene_time * float2(0.001f, -0.001f)));
	
	float4 b = whirl_color * whirl_color0 * whirl_color1;
	
	float4 campfire_emissive0 = float4(emmision_color.rgb, 0.0f) * float4(solid_emission_color.rgb,0.0f);
	float4 campfire_emissive1 = campfire_emissive0 * b;
	
	float4 campfire_emissive = campfire_emissive0 * campfire_emissive1;
	
	O.emissive.rgb = campfire_emissive.rgb * 0.25f;
	O.emissive.a   = 0.0f;
	
	return O;
}
