=====================================================================================
SNC 移行ガイド
=====================================================================================

このドキュメントでは、現在の GCC PPU ツールチェーンと SNC PPU ツールチェーンとの (開発に影響を与える可能性
のある) 相違点を説明します。スムーズな移行を可能にするため、SNC と GCC ツールチェーンとの互換性に関しては
最大限の対策が取られていますが、一部のソースコードを変更する必要がある場合があります。 

-------------------------------------------------------------------------------------
0. 要旨 
-------------------------------------------------------------------------------------

SN Compiler (SNC) には、業界標準の Edison Design Group (EDG) C/C++ フロント エンドが採用されて
います。これは、高いレベルで規格に準拠したフロント エンドです。準拠していないコードは、C++ の規格に対応した形
式に変更することをお勧めします。しかし SNC は、可能な限り互換性を維持するため、GNU および Microsoft の
拡張機能に各種対応しています。 

SNC では、SNC と GCC によってビルドされたコード間の完全なクラス レイアウトと、バイナリ リンク互換性を実現するた
め、GCC と同じ C++ ABI が使用されます。

1 つの大きな相違点は、インライン アセンブリの使用方法です。SNC では、低レベル コードに対して組込み関数ベー
スのアプローチが使用されるため、コンパイラでは GNUスタイルのインライン アセンブリに対するサポートが提供されません。 
組み込み関数では、最適化機能との高度な統合が可能になっているため、最適化機能を有効することにより、C/C++
とインライン アセンブリが混合する場合より良いコードを作成することができます。インライン アセンブリからの移行を支援
するため、それに対応するイントリンシックの総合的なセットが用意されています。 

1つの大きな相違点は、インライン アセンブリの使用です。SNCでは、コンパイラでインライン アセンブリの対応がなされな
いように、低水準コード用にイントリンシクス ベースのアプローチがとられています。イントリンシクスは、オプティマイザとの高
度な統合性があるため、C/C++ とインライン アセンブリが混合した場合よりも適切なコードが生成されるように、有効化
すべきです。インライン アセンブリの使用からの移行プロセスを支援するために、対応するイントリンシクスが幅広く揃えら
れています。

SNC は、PlayStation(R)3 専用に設計された総合的な最適化機能を搭載しています。この機能では、各種の状況に
応じた柔軟な設定が可能になっています。速度とサイズの最適なバランスを実現するには、可能な限り「-O5」を使用しま
すが、インライン化およびその他の最適化設定を試し、プロジェクト レベル、および重要な関数がある場合は関数レベル
(コントロール プラグマを使用) での最適な設定を探すことをお勧めします。 

SNC ツールチェーンのサポートに関しては、サポート担当者までお問い合わせください。 

-------------------------------------------------------------------------------------
1. SNC ツールチェーンの将来のリリースで予定されている変更点 
-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------
1.1 C++ 例外処理 
-------------------------------------------------------------------------------------

このリリースのツールチェーンは、C++ 例外処理には対応していません。この対応は新しい GCC 互換の実装が完成する
まで除去されていました。将来的なリリースでこの対応が予定されています。

-------------------------------------------------------------------------------------
1.2 「vecreg」言語拡張機能 
-------------------------------------------------------------------------------------

このリリースのツールチェーンは、「vecreg」言語拡張機能には対応していません。将来的なリリースでこの対応が予定さ
れています。

-------------------------------------------------------------------------------------
2. SNC と GCC との相違点 
-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------
2.1 インライン アセンブリからイントリンシックへの変換 
-------------------------------------------------------------------------------------

SNC では、GNUスタイルのインライン アセンブリに対応していません。コンパイラによる介入なしに、asm ブロックのコンテン
ツが直接アセンブラに渡される場合は、「Raw」インライン アセンブリがサポートされます。インライン アセンブリの使用はで
きるだけ避け、代わりに、提供されている総合的な組み込み関数セットのご使用をお勧めします。これにより、コンパイラの
最適化機能との統合が、インライン アセンブリより確実になります。用意されているイントリンシックのセットは、現在使用
されているインライン アセンブリ命令と 1 対 1 で対応しています。 

イントリンシクスのコア セットはコンパイラ本体に組み込まれています。それ以外は、多数のヘッダ ファイルで提供されてい
ます。コア イントリンシスクの一覧は、host-win32\sn\help\intrinsics.htmを参照してください。

イントリンシクス ヘッダ ファイル:

1. target\ppu\include\ppu_intrinsics.h 

ラッパー ファイル「ppu_intrinsics.h」には、コンパイルで使用するコンパイラに応じて「ppu_intrinsics_snc.h」ま
たは「ppu_intrinsics_gcc.h」が含まれます。これらのファイルには、各コンパイラに内蔵されていないイントリンシックの
定義が含まれています。

ファイルコンパイラ間での互換性を確保するために、イントリンシクスを使用する任意のファイルに必ず
「ppu_intrinsics.h」を含めることが推奨されます。

2. target\ppu\include\ppu_asm_intrinsics.h

ファイル「ppu_asm_intrinsics.h」には、SNC および GCC へのアセンブリ言語コードの移植に役立つイントリンシクス
のセットが数多く提供されています。  このイントリンシクス セットにより、PPU 命令セットのサブセットである SNC と GCC
の両方用の実装が提供されます。

これらのイントリンシクスは、コンパイラ ビルトインとインライン関数の組み合わせとして導入されます。

3. target\ppu\include\ppu_altivec_internals.h

SNC は、altivec.h の実装に GCC で使用される非標準の GCC 固有ビルトイン全てに対応しているわけではありま
せん。ただし、GCC からのコードの移植に役立つようにこれらの一部が提供されています。  

これらの内部イントリンシクスは、GCC により公式的に対応しているものではなく、将来的に変更されたり、GCC から除去
される可能性があることに注意してください。  

内部イントリンシクスのこれらの SNC エミュレーションは次のファイルで定義されています。

以下は、インライン アセンブリからイントリンシックへの変換の一般的な例です。 

a) 時間ベースからの移動 

    インライン アセンブリの場合 
    asm volatile ("mftb %0" : "=r"(time));
    
    イントリンシックの場合 
    time = __mftb();

b) レジスタからの値の直接の取得 

    インライン アセンブリの場合 
    __asm__ volatile ( "ori %0,13,0" : "=r"( value ) ); 
    or
    __asm__ volatile ( "mr %0, 13" : "=r"( value ) ); 
    
    イントリンシクスのバージョン:
    value = __reg( 13 );

c) TRAP 命令の挿入 

    インライン アセンブリの場合 
    __asm__ volatile ( "tw 31,1,1" ) ;
    
    イントリンシクスのバージョン: 
    __builtin_snpause();


一般的にインライン アセンブリは、デバッグを目的とした完全なスタック トレースの取得に使用します。これは、以下のように「__builtin_frame_address()」イントリンシックを使用することによって簡単に実行できます。 

int getStackTrace( unsigned int* trace, int maxtrace ) 
{ 
    int numAddresses = 0; 
    void *stack_frame = __builtin_frame_address(); 

    do
    { 
        trace[ numAddresses++ ] = (unsigned int)stack_frame; 
        stack_frame = (void*)(int)*(long long*)stack_frame; 
    } while( stack_frame != 0 && numAddresses != maxtrace ); 

    return numAddresses; 
}

-------------------------------------------------------------------------------------
2.2 C と C++ とのリンク互換性
-------------------------------------------------------------------------------------

現時点で、SNC では GCC と同じ C++ ABI が実装されます (IA64 C++ ABI 標準に基づく)。SNC と GCC のビ
ルド コードは、現在では完全にバイナリ リンク互換性があります。

-------------------------------------------------------------------------------------
2.3 C++ クラス レイアウトの互換性 [*** β版機能 ***] 
-------------------------------------------------------------------------------------

これは、β版の機能の一つです。問題が発生した場合には、通常のサポート経路での報告をお願いします。

現時点で、SNC では GCC と同じ C++ ABI が実装されます (IA64 C++ ABI 標準に基づく)。
SNC と GCC のビルド コードは、現在では完全にクラス レイアウトの互換性があります。
 
-------------------------------------------------------------------------------------
2.4 __fastcall と関数ポインタ 
-------------------------------------------------------------------------------------

PS3 で使用される標準の PPU ABI (Application Binary Interface) では、関数記述子のデータ テーブル
を経由して関数ポインタがコールされます。この間接的な処理は、ポインタを経由した関数コールにおける大きなオーバー
ヘッドの原因になります。SNC には、直接のコールを実行してこのオーバーヘッドを排除する、別の関数コール方式が用
意されています。このコール方式は、関数および関数へのポインタに「__fastcall」宣言修飾子を追加することによって
指定します。 

例 

typedef int ( __fastcall *OpFn )( int, int );

int __fastcall OpAdd ( int a, int b ) { return ( a + b ); } 
int __fastcall OpSub ( int a, int b ) { return ( a - b ); } 

int PerformOp ( OpFn op, int a, int b ) { return( (op)( a, b ) ); } 

void Test (void)
{ 
    int sum = PerformOp( OpAdd, 1, 2 );
    int dif = PerformOp( OpSub, 1, 2 );
} 

「__fastcall」関数ポインタを使用して SNC で直接コールを行った場合、TOC の変更は行われず、プロシージャ記述
子を最初に逆参照する代わりに、関数ポインタを直接コールします。SNC では TOC が使用されないため、SNC でビルド
されたコードではこれは問題にはなりませんが、GCC でビルドされたコードをコールした場合は正しく機能しない可能性があ
ります。 

ライブラリ、OS、GCC でビルドされたその他のコードでは標準の ABI が前提となっているため、OS または GCC でビルドさ
れたライブラリに関数ポインタをパスする際に「__fastcall」を使用することはできません。「__fastcall」は、以下のいず
れのタイプの関数に対しても使用しないようにしてください。 

    * スレッド開始関数 
    * qsort 比較コールバック 
    * その他すべての OS/SDK コールバック 
    * GCC でコンパイルされた関数 

-------------------------------------------------------------------------------------
2.5 AltiVec 
-------------------------------------------------------------------------------------

SNC は、デフォルトで AltiVec に対応しています。SDK に含まれている GCC のヘッダ ファイル「altivec.h」は、
SNC では必要ありません。プレースホルダ ファイル「host-win32/sn/ppu/include/altivec.h」は、GCC でこれを
必要とするコードとの互換性を維持するため、この場所に格納されています。 
host-win32/sn/ppu/include/altivec. 
  

メモ：SNC は、GCC で altivec.h の実装に使用される GCC 専用の非標準ビルドインのすべてに対応しているわけ
ではありません。これらの一部は、GCC からのコード移植を支援する目的で用意されています。

これらの内部イントリンシクスは、GCC により公式的に対応しているものではなく、将来的に変更されたり、GCC から除去
される可能性があることに注意してください。

これらの内部イントリンシクスの SNC エミュレーションを使用するには、次のファイルをインクルードしてください。
'ppu_altivec_internals.h'.

-------------------------------------------------------------------------------------
2.6 マクロ プリセット 
-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------
2.6.1  あらかじめ定義されたマクロ
-------------------------------------------------------------------------------------

SNC には、コンパイラおよびターゲット プロセッサを認識するための以下のマクロが、プリセットで用意されています。 

    * __SNC__
    * __PPU__
    * __CELLOS_LV2__
    * _ARCH_PPC64

また SNC では、GCC との互換性を目的とした以下のマクロも用意されています。さらに SNC には、GCC で作成された
コードの移植に便利な GCC 言語拡張機能が多く導入されています。 

    * __GNUC__

SNC と GCC とを区別するには、「__GNUC__」をチェックする前に「__SNC__」定義を確認する必要があります。. 

-------------------------------------------------------------------------------------
2.6.2
-------------------------------------------------------------------------------------

GCC では、以下に記載する #error プリプロセッサ命令の例外的使用 (必須である終了引用符がかけている状態)
が受け入れられます。

#if 0
#error "This is an error!
#endif

SNC では、#endif の欠如が報告されます。

-------------------------------------------------------------------------------------
2.7 vecreg 
-------------------------------------------------------------------------------------

今回のリリースは、GCC の「vecreg」言語拡張機能には対応していません。 

-------------------------------------------------------------------------------------
3. コマンドライン オプション 
-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------
3.1 メインの最適化レベル (-O<n>) 
-------------------------------------------------------------------------------------

リリース 1.1.0.1 以降、SNC のオプティマイザ制御は簡略化され、GCC のものに近くなるように変更されてきました。

SNC のメイン オプティマイザは、コマンドライン スイッチ -O<n> (<n> には 0 から 3 が入る) によって制御されます。

-O0 の場合、オプティマイザは実行されません。-O1 から -O3 の場合、最適化が徐々に度合いを強めて実行され、
-O3 では有効なほとんどすべての最適化が実行されます。一部の最適化は -O3レベルでさえも実行されませんが、こ
れは、これらが特定の状況下にのみ該当するためです。詳細は以下を参照してください。-O2 が基本的で保守的な
最適化となります。

-Os では、速度を犠牲にする可能性があっても、サイズに対する最適化をコンパイラに指示します。

-Od では、コードのデバッグ難易度を上げる最適化 (命令のスケジューリングなど) の回避をコンパイラに指示します。
このモードは、妥当なランタイムパフォーマンスで、きわめてデバッグしやすいコードを生成するように設計されています。


最適なサイズと速度を得るため、可能な場合は常に -O3 を使用することをお勧めします。

-O0 (デフォルト)	最適化なし、インライン化なし (強制インライン化を除く)。
-O1		最適化なし、インライン化を許可。
-O2		完全な最適化。
-O3		完全な最適化、およびより時間のかかる最適化 (本リリースでは使用不可)。

-Od		デバッグ可能な最適化済みコードの生成 (-g と共に使用する必要あり)。
-Os		コードサイズを増加させる可能性のある最適化を避けた、最適化済みコードの生成 (下記のメ
		モを参照)。

これまでの -O4 と -O5 スイッチは、-O3 と同様に取り扱われるようになりました。

メモ：

インライン化設定は、コード サイズに影響を与えるもっと重要な要因です。最適なインライン化設定は、コードが記述さ
れる言語とスタイルに依存します。C や C++ プログラムでは、最適な結果を得るために異なる設定が必要となる場合
があります。アプリケーションに対する最適なサイズとパフォーマンスのバランスを得るには、インライン化制御のテスト実行
を強くお勧めします。

-------------------------------------------------------------------------------------
3.2 SSA 「ポスト」最適化レベル (-Xpostopt=<n>) 
-------------------------------------------------------------------------------------

「-Xpostopt=<n>」スイッチ (<n> は 0 ～ 6) では、SSA のポスト最適化機能を制御できます。これは、
PlayStation(r)3 専用に設計および導入された新しい最適化フェーズです。PPU 専用の最適化のほとんどはポスト
最適化機能で実行され、新しい最適化機能が認識された際に迅速かつ効率的に実装できるように設計されています。 

「-O2」での「-Xpostopt」のデフォルト レベルは 6 (最高) となっています。「-O2」で問題が発生した場合は、最初に
「-O2 -Xpostopt=0」の組み合わせを試し、次に「Xpostopt」を可能な値まで徐々に上げることをお勧めします。 

より高いレベルでの最適化で問題が発生した場合には、お知らせください。

-------------------------------------------------------------------------------------
3.2.1 デフォルで有効にされていない SSA 「ポスト」最適化 (-Xfastmath)
-------------------------------------------------------------------------------------

SNC 220.1 での新規内容：

SSA オプティマイザでは、-Xfastmath スイッチで有効にされる付加的最適化が多数提供されます。
  
これには以下が含まれます。
    * if ステートメントを「fsel」に変換
    * 浮動小数点、整数、VMX レジスタ間の変換を避けるため、VMX レジスタを自動的に使用。これにより、Load
      Hit Store ペナルティの数が削減されます。
    * 「fdiv」をおおよその分配と精度に置換。

浮動小数点値 (「denormal」数など) の境界ビヘイビアに依存するコードと、これら最適化が正常に動作しない恐れ
があるため、このスイッチはデフォルトでは有効にされていません。これは大部分のコードに影響しないため、最適化ビルド
においては –Xfastmath を可能な限り有効にしておくこと、およびこれら境界条件に依存するコードがこれと動作する
ように変更することを強くお勧めします。

-------------------------------------------------------------------------------------
3.3 緩いエイリアス レベル (-Xrelaxalias=<n>) 
------------------------------------------------------------------------------------- 

このスイッチでは、エイリアス分析ルールを制御します。 

    * 「-Xrelaxalias=0」は、GCC の「-fno-strict-aliasing」に該当します。 
    * 「-Xrelaxalias=2」は、GCC の「-fstrict-aliasing」とほぼ同等です。 

コードは、最低でも「-Xrelaxalias=2」(C99 エイリアス ルール) に対応するように記述することをお勧めします。エイ
リアス ルールを厳格にすることにより、場合によってはコンパイラでより良いコードを生成することが可能になります。 

厳格なエイリアス ルールを使用している場合でも、「__may_alias」属性を使用してエイリアス ポインタを故意にマーク
することもできます。 

-Xrelaxalias=<n> の n の値による違い 

    * 0 - 保守的なエイリアス分析 
    * 1 - タイプ インスタンスが重複しないことを前提とした緩いエイリアス分析 
    * 2 - C99 エイリアス ルールを前提とした緩いエイリアス分析 (「-O5」のデフォルト) 
    * 3 - const 変数および non-const 変数がエイリアス化されていないことを前提とした、さらに緩いエイリアス
      分析 

------------------------------------------------------------------------------------- 
3.4 インライン化の制御 
-------------------------------------------------------------------------------------

SNC でのインライン化の制御には、3 つのメイン スイッチを使用します。これらの値を調節することにより、コンパイル後の
コードのサイズと実行速度が大幅に向上する場合があります。しかし、すべてのコード記述スタイルに最適となるデフォルト
値はありません。このため、いろいろな値を試し、記述しているコードに最適な値を探すことを強くお勧めします。 

これらの制御で使用するパラメータは、「命令」に関する関数の最大サイズを表わします。これらはコンパイラの内部命令
のため、個々のプロセッサの命令と同じである必要はありません。 


-------------------------------------------------------------------------------------
3.4.1    -Xautoinlinesize=<n>：自動インライン化を制御 
-------------------------------------------------------------------------------------

このスイッチでは、ソース コードでインラインとしてマークされていなくてもコンパイラによって自動的にインライン化される関
数の最大サイズを制限します。このスイッチは、ヘッダ ファイルのクラス内で定義されている C++ メソッドなどの黙示的
なインライン関数には、適用されません (「-Xinlinesize」を参照)。 

-Xautoinlinesize=<n> の n の値による違い 

    * 0 - 自動インライン化なし 
    * 64 - (デフォルト) 
    * <n> - 最大サイズ <n> 個の命令までのマークされていない関数の自動インライン化が有効になります。 

-------------------------------------------------------------------------------------
3.4.2    -Xinlinesize=<n>：黙示的インライン関数のインライン化を制御 
-------------------------------------------------------------------------------------

このスイッチでは、コンパイラによってインライン化される黙示的インライン関数の最大サイズを制限します。黙示的インライ
ン関数には、ヘッダ ファイルのクラス内で定義されている C++ メソッドなどが含まれます。 

-Xinlinesize=<n> の n の値による違い 

    * 0 - 黙示的インライン化なし 
    * 384 - (デフォルト) 
    * <n> - 最大サイズ <n> 個の命令までの黙示的インライン関数の自動インライン化が有効になります。 

-------------------------------------------------------------------------------------
3.4.3    -Xinlinemaxsize=<n>：1 つの関数へのインライン化の最大数を制御                               
-------------------------------------------------------------------------------------

このスイッチでは、1 つの関数へのインライン化の最大数を制御します。このスイッチは、個々の関数が肥大化して最適
化のほかの段階の処理速度が低下することを防止するために使用します。この値をデフォルト値以上に設定すると、コ
ンパイルには時間がかかりますが、インラインの数が増加 (同時にパフォーマンスが向上) する場合があります。 

-Xinlinemaxsize=<n> の n の値による違い 

    * 0 - インライン化なし 
    * 5000 - (デフォルト) 
    * <n> - 最大サイズ <n> 個の命令までの関数へのインライン化が有効になります。 

------------------------------------------------------------------------------------- 
3.5 条件動作を使用して分岐を排除 (-Xbranchless=<n>) 
------------------------------------------------------------------------------------- 

この最適化では、コードを変換して条件動作を使用することによって分岐が排除されます。 

-Xbranchless=<n> の n の値による違い 

    * 0 - 最適化なし (デフォルト) 
    * 1 - 分岐を排除 

深くパイプライン化されたプロセッサでは、分岐ヒントが正しく機能している場合でも、分岐は非常に低速になります。コー
ドがあまり頻繁にコールされない場合は、icache の充填時間が原因で、生成された余分な命令が低速で動作する場
合がありますが、浮動小数点計算ではほぼ常に有効に作用します。 

例 

if( x > y ) x = y; 

上記のコードは、整数と浮動小数点の両方の変数において、選択命令を使用するように変換されます。 

x = x > y ?  x : y; 

同様の式を組み合わせることにより、分岐を排除することができない場合でも、さらに効率的なコードにすることができます。 

例 

if( x > y )
{ 
  return jim[ bert[ x ] ];
} 
else
{ 
  return jim[ bert[ y ] ];
} 

上記のコードは、以下のように変換することができます。 

return jim[ bert[ x > y ? x : y ] ];

-------------------------------------------------------------------------------------
3.6 ループの自動アンロール (-Xunroll=<n>) 
------------------------------------------------------------------------------------- 

この最適化では、ループが自動的にアンロールされてパフォーマンスが向上しますが、コードのサイズを縮小するため、デフ
ォルトではオフになっています。  
   これは、重要なループを含むコードに対して有効に利用できます。 

-Xunroll=<n> の n の値による違い 

    * 0 - 最適化なし (デフォルト) 
    * 1 - ループの自動アンロールをオン 

-------------------------------------------------------------------------------------
3.7 言語機能の制御 (-Xc+=...) 
-------------------------------------------------------------------------------------

「-Xc+=」フラグでは、有効にする言語機能を選択します (RTTI、c99 モードなど)。 

RTTI は、SNC においてデフォルトで有効となるように変更されました。これは、GCC のデフォルト ビヘイビアに合わせて
変更されたものです。

これを無効にするには、以下のコンパイラ スイッチをコマンドラインに追加する必要があります。

-Xc-=rtti

明示的に RTTI を有効にするには、以下を使用します。

-Xc+=rtti

この方法で制御可能な言語機能の完全リストは、メインのコンパイラ ドキュメントにあります。

-------------------------------------------------------------------------------------
4.  その他の情報 
-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------
4.1 プラグマを使用した最適化制御 
-------------------------------------------------------------------------------------

SNC では、プラグマを使用することにより、ファイル単位の場合より細かく最適化を制御することができます。以下は、ルー
プの自動アンロールを 1 つの関数に適用する場合の例です。 

#pragma control %push unroll=1

void functionToBeUnrolled()
{ 
    //... 
} 

#pragma control %pop unroll

この場合は、「-Xunroll=1」を使用してファイルがコンパイルされた場合と同様にこの関数が処理されます。 

また SNC は、C99 の「_Pragma」演算子にも対応しています。この演算子は、文字列の文字引数を非文字列化し、
マクロ展開による「#pragma」命令の効率的な生成を可能にします。この機能は、マクロを使用した最適化制御用プラグ
マを挿入する際に使用でき、それをリリース ビルドのデバッグ、異なる最適化方法、別のコンパイラとの互換性の、各目
的に適した形で定義することができます。 

以下の例では、SNC でのビルドにおけるサイズと速度の最適化の制御に「OPTIMIZE_FOR_SPEED」定義が使用されて
います。この機能により、ソース コード内の関数をサイズ重視や速度重視としてマークすることが可能になり、これをデバッグ
ビルドとリリースビルドで使い分けることや、必要なプラグマに対応しないコンパイラでは認識できないようにすることができます。 

メモ：この例では、_Pragma オペレータの使用について説明します。このオプションの組み合わせは、アプリケーションに対し
て必ずしも最高のパフォーマンスを実現するものではありません。

#if defined(__SNC__) && defined(OPTIMIZE_FOR_SPEED)
 // 速度重視の最適化ではインライン化とアンロールを使用 
  #define FORCE_INLINE _Pragma("inline")
  #define BEGIN_LOOP_UNROLLING _Pragma("control %push unroll") \
                               _Pragma("control unroll=1")
  #define END_LOOP_UNROLLING _Pragma("control %pop unroll")
#else
  // サイズ重視の最適化ではループをインライン化やアンロールしない 
  // (SNC 以外のコンパイラに対しては、最適化制御を「最適化なし」として定義) 
  #define FORCE_INLINE
  #define BEGIN_LOOP_UNROLLING
  #define END_LOOP_UNROLLING
#endif

BEGIN_LOOP_UNROLLING
FORCE_INLINE int InlineSum( int* pi, int count)
{ 
  int sum = 0;
  for (int i = 0; i < count; ++i)
  { 
    sum += pi[ i ];
  } 
  return( sum );
} 
END_LOOP_UNROLLING

-------------------------------------------------------------------------------------
4.2 診断用出力の制御 (警告の抑制)
-------------------------------------------------------------------------------------

SNC では、コマンドライン スイッチまたはプラグマを使用して、診断メッセージの重要性を完全に制御できます。 

診断用プラグマには、以下の形式を使用します。 

#pragma diag_<category>=<idlist> 

<category> は、診断メッセージに設定する診断カテゴリになります。 
 このカテゴリには、以下のいずれかを使用します。 

    * suppress - 診断メッセージを出力しない 
    * remark - コメント レベルの診断メッセージを出力 
    * warning - 警告レベルの診断メッセージを出力 
    * error - エラー レベルの診断メッセージを出力 
    * default - デフォルト カテゴリの診断メッセージを出力 

<idlist> は、診断番号または診断タグ名のカンマ区切りのリストになります (診断タグとその番号のリストは、エラー
ドキュメント ファイル「host-win32\sn\help\err_doc.htm」を参照)。 
 
例 

#pragma diag_suppress=implicit_return_from_non_void_function
または 
#pragma diag_suppress=942 

上記のプラグマは、非 void 関数からの戻り値がない場合の診断をオフにします。 

#pragma diag_error=942 

上記のプラグマでは、「エラー」が出力されます。 

#pragma diag_default=942 
上記のプラグマでは、非 void 関数からの戻り値がない場合の診断レベルが「warning」になります。 

コマンドラインからは、「-Xdiag_suppress=942」の形式でスイッチを追加して診断をオフにします。 

診断番号では、最初のゼロを省略してください (コンパイラで 8 進数として認識されるため)。 


------------------------------------------------------------------------------------- 
5. その他のツール 
-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------
5.1 既存プロジェクトへの SNC 設定の追加 
-------------------------------------------------------------------------------------

SN の Visual Studio .NET Integration 1.7.9 リリースには、GCC ベースの既存プロジェクトを SNC
で使用できるように簡単に変換するための新しいツール「AddSNCConfig_GUI.exe」(およびコマンドラインバージ
AddSNC.exe)が追加されています。

詳細は、VSI リリース ノートを参照してください。  

-------------------------------------------------------------------------------------
終了
-------------------------------------------------------------------------------------
