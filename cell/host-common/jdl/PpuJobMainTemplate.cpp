%(/*)
#########################################################
# SCE CONFIDENTIAL
# PlayStation(R)3 Programmer Tool Runtime Library 310.001
# Copyright (C) 2009 Sony Computer Entertainment Inc.
# All Rights Reserved.
#########################################################
%(*/)\
$(copyrightSourceHeader)

///////////////////////////////////////////////////////////////////////////////
//
//  JDL GENERATED FILE - DO NOT EDIT THIS FILE DIRECTLY
// 
///////////////////////////////////////////////////////////////////////////////

%(IF_EXIST:ppuJobMainCodeFileTop)\
$(ppuJobMainCodeFileTop)
%(END)\

#include <cell/spurs/job_descriptor.h>

#define CELL_JDL_JOB_MAIN
#include "$(managedFilePrefix)$(class).h"
#include <cell/jdl.h>

%(IF_EXIST:ppuJobMainCodeFileAfterIncludes)\
$(ppuJobMainCodeFileAfterIncludes)
%(END)\

%(IF_EXIST:namespace)\
%(FOR_TOKENS:namespace:$(COLON)$(SPACE))\
namespace $(TOKEN) {
%(END)\
%(END)\

%(IF_NOT_EXIST:cppClass)\
/// Implemented by user PPU code.
extern %(IF_EXIST:M.TYPE)$(M.TYPE)%(ELSE)void%(END) $(M.NAME)$(jobCallbackPostfix)(%(START_PARAMS),$(NEWLINE)%(END)%(SET_TAB:50:14)%(END)\
%( FOR_PARAMS)\
%(  PARAM)%(TAB)%(END)%(IF_EXIST:P.const)const %(END)$(P.TYPE)%(IF_EXIST:P.pass_by_ref)&%(END) $(P.NAME)%(END)\
%( END));
%(END)\

///////////////////////////////////////////////////////////////////////////////

extern void $(JobMethodName_macro)_ppuJobMain(CellSpursJob256 *pJob);

void $(JobMethodName_macro)_ppuJobMain(CellSpursJob256 *pJob)
{
    int _ret; (void)_ret;

    $(ppuCallPrefix)$(JobMethodName_macro)$(jobDescriptorPostfix)* _job = ($(ppuCallPrefix)$(JobMethodName_macro)$(jobDescriptorPostfix)*)pJob;
%(FOR_PARAMS)%(IF_NOT_EXIST:P.buffer)\
    $(P.TYPE) $(P.NAME) = _job->m.$(P.NAME);
%(END)%(END)\
%(FOR_PARAMS)\
%(/*) For each JDL buffer parameter, generate code depending on type of buffer. %(*/)\
%( IF_EXIST:P.input)\
    uint32_t _$(P.NAME)_eal = _job->m.$(P.NAME)[0].eal; (void)_$(P.NAME)_eal;
%(  IF_INT_LESS:P.aligned:dmaPadAlignThreshold)\
    _$(P.NAME)_eal += _job->m.$(P.NAME)_addr_offset;
%(  END)\
    $(P.TYPE) $(P.NAME) = ($(P.TYPE))(uintptr_t)_$(P.NAME)_eal;
    uint32_t _$(P.NAME)_size = $(_P_BUF_SIZE); (void)_$(P.NAME)_size;
%( END)\
%( IF_EXIST:P.out)\
    uint32_t _$(P.NAME)_eal = _job->m.$(P.NAME).eal;
%(  IF_INT_LESS:P.aligned:dmaPadAlignThreshold)\
%(  END)\
    $(P.TYPE) $(P.NAME) = ($(P.TYPE))(uintptr_t)_$(P.NAME)_eal;
    uint32_t _$(P.NAME)_size = $(_P_BUF_SIZE); (void)_$(P.NAME)_size;
%( END)\
%(/*) End of FOR_PARAMS %(*/)\
%(END)\

    /*E Alias resolve before function call */
    enum ptrEnum {
%(FOR_PARAMS)%(IF_EXIST:P.input)\
        k_$(P.NAME),
%(END)%(END)\
        k_numInputs
    };

    struct AliasCheck {
		void *orgPtr;
		void **ptr;
		uint32_t lsa;
		bool aliased;
	} inputPointers[k_numInputs];
%(FOR_PARAMS)%(IF_EXIST:P.input)\
    inputPointers[k_$(P.NAME)].ptr = (void **)(uintptr_t)&$(P.NAME);
    inputPointers[k_$(P.NAME)].lsa = _job->m.$(P.NAME)[0].qwLsa ? ((_job->m.$(P.NAME)[0].qwLsa<<4) | (_$(P.NAME)_eal&0xf)) : 0;
    inputPointers[k_$(P.NAME)].aliased = false;
%(END)%(END)\
    for(unsigned int _i = 0; _i < k_numInputs; _i++)
	{
		for(unsigned int _j = 0; _j < _i; _j++)
		{
            if (inputPointers[_i].lsa && (inputPointers[_i].lsa == inputPointers[_j].lsa))
			{
				inputPointers[_i].aliased = true;
				inputPointers[_i].orgPtr = *(inputPointers[_i].ptr);
				*(inputPointers[_i].ptr) = *(inputPointers[_j].ptr);
				break;
			}
		}
	}

%(IF_EXIST:M.TYPE)%(IF_NOT_EQUAL:M.TYPE:void)    _job->m.__return__value = %(END)%(END)\
%(IF_EXIST:cppClass)%(IF_EXIST:M.EXTRA.static)$(cppClass)::%(ELSE)_pthis_->%(END)%(END)$(M.NAME)%(IF_NOT_EXIST:cppClass)$(jobCallbackPostfix)%(END)(%(START_PARAMS), %(END)\
%(FOR_PARAMS)%(IF_NOT_EQUAL:P.NAME:_pthis_)\
%( PARAM)$(P.NAME)%(END)\
%(END)%(END));

    /*E Alias resolve after function call */
%(FOR_PARAMS)%(IF_EXIST:P.input)\
    if (inputPointers[k_$(P.NAME)].aliased)
	{
		__builtin_memcpy(inputPointers[k_$(P.NAME)].orgPtr, inputPointers[k_$(P.NAME)].ptr, _$(P.NAME)_size);
	}
%(END)%(END)\
$(ppuJobMainAppendCode)
}

%(IF_EXIST:namespace)\
%(FOR_TOKENS:namespace:$(COLON)$(SPACE))\
}
%(END)\
%(END)\

