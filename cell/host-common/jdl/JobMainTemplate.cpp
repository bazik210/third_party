%(/*)
#########################################################
# SCE CONFIDENTIAL
# PlayStation(R)3 Programmer Tool Runtime Library 310.001
# Copyright (C) 2009 Sony Computer Entertainment Inc.
# All Rights Reserved.
#########################################################
%(*/)\
$(copyrightSourceHeader)

///////////////////////////////////////////////////////////////////////////////
//
//  JDL GENERATED FILE - DO NOT EDIT THIS FILE DIRECTLY
// 
///////////////////////////////////////////////////////////////////////////////

%(IF_EXIST:jobMainCodeFileTop)\
$(jobMainCodeFileTop)
%(END)\

#include <cell/dma.h>
#include <cell/swcache.h>
#include <cell/spurs/job_chain.h>
#include <cell/spurs/job_queue.h>
#include <cell/spurs/job_context.h>
#include <cell/spurs/job_descriptor.h>

#define CELL_JDL_JOB_MAIN
#include "$(managedFilePrefix)$(class).h"
#include <cell/jdl.h>
#ifdef JDL_PAUSE_JOB
#include <LibSN_SPU.h>
#endif

%(IF_EXIST:jobMainCodeFileAfterIncludes)\
$(jobMainCodeFileAfterIncludes)
%(END)\


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

%(IF_EXIST:namespace)\
%(FOR_TOKENS:namespace:$(COLON)$(SPACE))\
namespace $(TOKEN) {
%(END)\
%(END)\
$(JobMethodName_macro)_context gContext_$(JobMethodName_macro);
%(IF_EXIST:namespace)\
%(FOR_TOKENS:namespace:$(COLON)$(SPACE))\
}
%(END)\
%(END)\

void $(jobMainFunctionName)(CellSpursJobContext2* pContext, CellSpursJob256 *pJob)
{
%(IF_EQUAL:spursJobBuildFlag:-mspurs-job)%(IF_NOT_EQUAL:spursJobBssClear:0)\
	cellSpursJobInitialize();
%(END)%(END)\
#ifdef JDL_PAUSE_JOB
	snPause();
#endif
%(IF_EXIST:namespace)\
    using namespace %(START_PARAMS)::%(END)%(FOR_TOKENS:namespace:$(COLON)$(SPACE))%(PARAM)$(TOKEN)%(END)%(END);
%(END)\
    int _ret; (void)_ret;
%(DEFINE:USE_SWCACHE)0%(END)\
%(IF_EXIST:useSwcache)%(IF_NOT_EQUAL:useSwcache:0)\
%( IF_NOT_EXIST:Swcache)%(ERROR)Swcache implementation is not defined%(END)%(END)\
%( IF_NOT_EXIST:sizeSwcache)%(ERROR)sizeSwcache is not defined%(END)%(END)\
%( DEFINE:USE_SWCACHE)1%(END)\
	char *pSwcacheHeap = (char *)pContext->ioBuffer + pJob->header.sizeInOrInOut - ($(sizeSwcache));
	cell::swcache::CacheResource<$(Swcache) >::initialize(pSwcacheHeap, $(sizeSwcache));
%(END)%(END)\

%(FOR_PARAMS)\
%( IF_EXIST:P.virtual)\
%(  IF_EQUAL:USE_SWCACHE:0)%(ERROR)virtual paramater is used, but Swcache is not enabled%(END)%(END)\
%(  DEFINE:useVirtual)1%(END)\
%( END)\
%(END)\
%(IF_NOT_EQUAL:useVirtual:0)\
    cell::swcache::ClassIdTabHeader *pClassIdTab = (cell::swcache::ClassIdTabHeader *)pContext->cacheBuffer[$(M.cache.count)];
    cell::swcache::ClassIdTabHeader::setClassIdTabOnSPU(pClassIdTab);
%( IF_EXIST:VirtualClassList)\
    extern cell::swcache::Vtab *g_BuildVtable_$(class)(unsigned short,cell::swcache::Vtab*);
    cell::swcache::ClassIdTabHeader::setFpBuildVtable(g_BuildVtable_$(class));
%( ELSE)\
    extern cell::swcache::Vtab *gBuildVtable(unsigned short,cell::swcache::Vtab*);
    cell::swcache::ClassIdTabHeader::setFpBuildVtable(gBuildVtable);
%( END)\
%(END)\

    $(JobMethodName_macro)$(jobDescriptorPostfix)* _job = ($(JobMethodName_macro)$(jobDescriptorPostfix)*)pJob;
    uint32_t _ibuf = (uint32_t)pContext->ioBuffer; (void)_ibuf;
    uint32_t _sbuf = (uint32_t)pContext->sBuffer; (void)_sbuf;
    uint32_t _obuf = (uint32_t)pContext->oBuffer; (void)_obuf;
    uint32_t _dmaTag = pContext->dmaTag; (void)_dmaTag;
    uint32_t _cacheIndex = 0; (void)_cacheIndex;
    gContext_$(JobMethodName_macro).pContext = pContext;
    gContext_$(JobMethodName_macro).pJob = _job;
%(FOR_PARAMS)%(IF_NOT_EXIST:P.buffer)\
    $(P.TYPE) $(P.NAME) = _job->m.$(P.NAME);
%(END)%(END)\
%(FOR_PARAMS)\
%(/*) For each JDL buffer parameter, generate code depending on type of buffer. %(*/)\
%(IF_EXIST:P.input)%(IF_NOT_EXIST:P.reserve)\
    uint32_t _$(P.NAME)_eal = _job->m.$(P.NAME)[0].eal; (void)_$(P.NAME)_eal;
%(IF_EXIST:P.swcache)\
%( IF_EQUAL:USE_SWCACHE:0)%(ERROR)Argument "$(P.NAME)" of "$(JobMethodName_macro)" has virtual attribute, but swcache is not initialized%(END)%(END)\
    if (__builtin_expect(_$(P.NAME)_eal != 0, 1))
    {
        _$(P.NAME)_eal += 16; _ibuf += 16;
    }
%(END)\
%( IF_INT_LESS:P.aligned:dmaPadAlignThreshold)\
    _ibuf += _job->m.$(P.NAME)_addr_offset;
    _$(P.NAME)_eal += _job->m.$(P.NAME)_addr_offset;
	$(P.TYPE) $(P.NAME) = $(_P_LS_PTR_IN);
    uint32_t _$(P.NAME)_size = $(_P_BUF_SIZE); (void)_$(P.NAME)_size;
    _ibuf = ((_ibuf + _$(P.NAME)_size + $(_ALIGNSUB1))&~$(_ALIGNSUB1));
%( ELSE)\
    $(P.TYPE) $(P.NAME) = $(_P_LS_PTR_IN);
    uint32_t _$(P.NAME)_size = $(_P_BUF_SIZE); (void)_$(P.NAME)_size;
    _ibuf += _$(P.NAME)_size;
%( END)\
%(END)\
%(IF_EXIST:P.swcache)\
    void *_$(P.NAME) = (void *)$(P.NAME);
    _ret = $(Swcache)::grabWithNoAlloc(_$(P.NAME), _$(P.NAME)_eal, _$(P.NAME)_size, %(IF_EXIST:P.inout)cell::swcache::IS_WRITABLE%(ELSE)0%(END), _dmaTag, %(IF_EXIST:P.virtual)1%(ELSE)0%(END));
    JDL_ASSERT(_ret >= 0 || _ret == CELL_SWCACHE_ERROR_NULL_POINTER);
    $(P.NAME) = ($(P.TYPE))_$(P.NAME);
    $(Swcache)::waitForGrab((void *)$(P.NAME));
%(END)\
%(END)\
%(IF_EXIST:P.out)%(IF_NOT_EXIST:P.reserve)\
    uint32_t _$(P.NAME)_eal = _job->m.$(P.NAME).eal;%(IF_EXIST:P.manual) (void)_$(P.NAME)_eal;%(END)
%( IF_INT_LESS:P.aligned:dmaPadAlignThreshold)\
    _obuf += (_$(P.NAME)_eal&$(_ALIGNSUB1));
    $(P.TYPE) $(P.NAME) = $(_P_LS_PTR_OUT);
    uint32_t _$(P.NAME)_size = $(_P_BUF_SIZE); (void)_$(P.NAME)_size;
    _obuf = ((_obuf + _$(P.NAME)_size + $(_ALIGNSUB1))&~$(_ALIGNSUB1));
%( ELSE)\
    $(P.TYPE) $(P.NAME) = $(_P_LS_PTR_OUT);
    uint32_t _$(P.NAME)_size = $(_P_BUF_SIZE); (void)_$(P.NAME)_size;
    _obuf += _$(P.NAME)_size;
%( END)\
%(END)%(END)\
%(IF_EXIST:P.cache)\
    uint32_t _$(P.NAME)_ls = (uint32_t)pContext->cacheBuffer[_cacheIndex++];
%( IF_INT_LESS:P.aligned:dmaPadAlignThreshold)\
    _$(P.NAME)_ls += _job->m.$(P.NAME)_addr_offset;
%( END)\
    $(P.TYPE) $(P.NAME) = %(IF_EXIST:P.non_null)($(P.TYPE))_$(P.NAME)_ls%(ELSE)_job->m.$(P.NAME).eal ? ($(P.TYPE))_$(P.NAME)_ls : ($(P.TYPE))(uintptr_t)0%(END);
%(END)\
%(IF_EXIST:P.scratch)\
    uint32_t _$(P.NAME)_size = ($(_P_BUF_SIZE)+15)&~15; (void)_$(P.NAME)_size;
    $(P.TYPE) $(P.NAME) = ($(P.TYPE))_sbuf;
    _sbuf += _$(P.NAME)_size;
%(END)\
%(/*) End of FOR_PARAMS %(*/)\
%(END)\
%(/*) Handle reserve buffers after all other buffers %(*/)\
%(FOR_PARAMS)%(IF_EXIST:P.reserve)\
%( IF_EXIST:P.input)\
    uint32_t* _$(P.NAME)_res_buf = &_ibuf;
%( END)\
%( IF_EXIST:P.out)\
    uint32_t* _$(P.NAME)_res_buf = &_obuf;
%( END)\
    $(P.TYPE) $(P.NAME) = ($(P.TYPE))*_$(P.NAME)_res_buf;
    *_$(P.NAME)_res_buf += (($(_P_BUF_SIZE)+15)&~15);
%(END)%(END)\

%(IF_EXIST:M.TYPE)%(IF_NOT_EQUAL:M.TYPE:void)
    _job->m.__return__value = %(END)\
%(END)\
%(IF_EXIST:cppClass)%(IF_EXIST:M.EXTRA.static)$(cppClass)::%(ELSE)_pthis_->%(END)%(END)$(M.NAME)%(IF_NOT_EXIST:cppClass)$(jobCallbackPostfix)%(END)(%(START_PARAMS), %(END)\
%(FOR_PARAMS)\
%( IF_NOT_EQUAL:P.NAME:_pthis_)\
%(  PARAM)$(P.NAME)%(END)\
%( END)\
%(END));

%(IF_EXIST:M.TYPE)%(IF_NOT_EQUAL:M.TYPE:void)\
    _jdl_mfc_put_large_unaligned(&_job->m.__return__value, (uint32_t)&(*($(JobMethodName_macro)$(jobDescriptorPostfix)*)(uint32_t)pContext->eaJobDescriptor).m.__return__value,
                                 sizeof(_job->m.__return__value), _dmaTag, MFC_PUT_CMD, __alignof(_job->m.__return__value));
%(END)%(END)\

%(FOR_PARAMS)\
%( IF_NOT_EXIST:P.manual)%(IF_NOT_EXIST:P.reserve)\
%(  IF_EXIST:P.inout)\
%(   IF_EXIST:P.swcache)\
    unsigned int $(P.NAME)_dmaTag; (void)$(P.NAME)_dmaTag;
    uint32_t $(P.NAME)_ea; (void)$(P.NAME)_ea;
    if (($(Swcache)::query((void*)$(P.NAME), $(_P_BUF_SIZE), $(P.NAME)_dmaTag, $(P.NAME)_ea) & 0x1f) == cell::swcache::CACHED)
    {
    	$(Swcache)::MemBlockHeader *p_$(P.NAME)_header = $(Swcache)::MemBlockHeader::getHeader((void *)$(P.NAME));
        p_$(P.NAME)_header->$(Swcache)::MemBlockHeader::releaseObject(_dmaTag);
    }
%(   ELSE)\
%(    IF_INT_LESS:P.aligned:dmaPadAlignThreshold)\
    _jdl_mfc_put_large%(IF_INT_LESS:P.aligned:16)_unaligned%(END)($(P.NAME), _$(P.NAME)_eal, _$(P.NAME)_size, _dmaTag, MFC_PUT%(IF_EXIST:P.fence)F%(END)_CMD%(IF_INT_LESS:P.aligned:16), $(P.aligned)%(END));
%(    ELSE)\
    mfc_putl%(IF_EXIST:P.fence)f%(END)($(P.NAME), 0, _job->m.$(P.NAME), (($(_P_BUFFER_1)+16*1024-1)/(16*1024))*sizeof(uint64_t), _dmaTag, 0, 0);
%(    END)\
%(   END)\
%(  END)\
%(  IF_EXIST:P.out)\
    _jdl_mfc_put_large%(IF_INT_LESS:P.aligned:16)_unaligned%(END)($(P.NAME), _$(P.NAME)_eal, _$(P.NAME)_size, _dmaTag, MFC_PUT%(IF_EXIST:P.fence)F%(END)_CMD%(IF_INT_LESS:P.aligned:16), $(P.aligned)%(END));
%(  END)\
%( END)%(END)\
%(END)\

%(IF_NOT_EQUAL:USE_SWCACHE:0)\
    cell::swcache::CacheResource<$(Swcache) >::finalize(_dmaTag);
%(END)\
%(UNDEF:USE_SWCACHE)%(END)\

$(jobMainAppendCode)
#ifdef _DEBUG_DMA
    cellDmaWaitTagStatusAll(0xffffffff);
#endif
}

