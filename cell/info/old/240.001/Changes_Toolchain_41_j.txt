[SCE CONFIDENTIAL DOCUMENT]
PLAYSTATION(R)3 Programmer Tool Toolchain 240.001
                    Copyright(C) 2008 Sony Computer Entertainment Inc.
                                                  All Rights Reserved.
======================================================================
以下にPLAYSTATION(R)3 Reference Tool ツールチェーンパッケージの変更点と
不具合修正を記述します。

- Release 240.001 の変更点
- Release 240.001 の不具合修正

======================================================================
Release 240.001 の変更点
----------------------------------------------------------------------
SN Systems社製リンカ
----------------------------------------------------------------------
(B#47042)
- GNU 「--target-help」スイッチに対するサポートを追加しました。

(B#48517)
- 未定義の参照が検出された場合にインスタンス化される、ELF セクションの
  始まりと終わりに対し、GNU ldスタイルの擬似シンボルを実装しました。
  「__start_XXX」または「__stop_XXX」という名前のシンボルを使用する場合、
  リンカでは「XXX」という名前のセクションのアドレスを生成します。
  唯一の制限として、セクション名は C 名称として表せるものであることが
  挙げられます (英数字とアンダースコアのみ使用可)。

  例:

  #include <stdio.h> 
  #include <stdlib.h> 

  #define SECTION(x)  __attribute__ ((section (x)))

  int bar_var_1 SECTION ("bar");
  int bar_var_2 SECTION ("bar");

  /* symbols generated by the linker! */
  extern void * __start_bar;
  extern void * __stop_bar;

  int main ()
  { 
     printf ( "__start_bar=%p, &bar_var_1=%p, &bar_var_2=%p __stop_bar=%p\n",
              &__start_bar, &bar_var_1, &bar_var_2, &__stop_bar
            );
     return EXIT_SUCCESS;
  }

(B#50175)
- セクションの開始や停止に関する擬似シンボルを実装しました。
  セクション名が「.」で始まるものの、それ以外は有効な C識別子がリンカ
  で検出された場合、そのセクションの始まりと終わりを示すシンボルが、リ
  ンカによって推論的に生成されます。 これらシンボルに対する未解決の参
  照がリンカ インプット内で検出された場合、生成されたシンボルがリンカ
  アウトプットで個別に定義され、参照はこれらを指すように解決されます。
  シンボル名は、先頭の「.」がシーケンス「_Z」に置換され、変更セクション
  名の接頭辞に「__start_」または「__stop_」が追加されて生成されます。
  (例えば、「.text」セクションの始まりは「__start__Ztext」となります)

  例:

  #include <stddef.h>

  extern const unsigned char __start__Ztext [];
  extern const unsigned char __stop__Ztext [];

  ptrdiff_t size_of_dot_text (void)
  {
      return &__stop__Ztext [0] - &__start__Ztext [0];
  }

(B#46925)
- ランタイムオブジェクト付きのPRXのサポートを追加しました。リンカに追加
  されたスイッチ--prx-with-runtimeは、--oformat=prx/sprxと組み合わせると、
  Cのランタイムライブラリとのリンクができるようになります。
  GCCとの互換性のために-mprx-with-runtimeも追加されています。

(B#47101)
- 署名付きELFファイルのリンカでの直接生成をサポートしました。この内部
  処理によって、make_fselfツールでリンカの生成したELFファイルをコピー
  するのにかかる時間をなくすことができます。
    --oformat=fself :
      署名付き出力ファイルを直接生成するようにリンカに指示します。
    --oformat=fself_npdrm :
      ネットワークゲーム用の署名付き出力ファイルを直接生成するよう
      にリンカに指示します。
    --external-make-fself :
      内部処理ではなく、元のmake_fself/make_fself_npdrmツールを使う
      ようにリンカに指示します。

(B#48512)
- SNツールチェーンの#pragma comment (lib, ...)のサポートを追加しました。

(B#49415)
- FSELFにSHA-1ダイジェストを入れる機能を実装しました。
  この機能はデフォルトでは無効になっており、--write-fself-digestスイッ
  チで有効になります。

(B#51507)
- --ppuguidおよび--no-ppuguidスイッチを追加しました。
  --ppuguidを使用すると、PPU GUIDエントリを最終出力に追加します。
  デフォルトではPPU GUIDを生成しません。

- コードおよび読み取り専用データの重複の除去をサポートしました。
  --strip-duplicatesスイッチを、--strip-unusedまたは--strip-unused-data
  と組み合わせて使うと有効になります。

- .debug_lineデータが膨大になった場合のために、レイアウトに隙間を許す
  --pad-debug-line=Xスイッチを追加しました。

[仕様変更]

(B#46171)
- 未定義のシンボルが報告された場合、シンボル名を二重引用符で囲むように
  変更しました。これは、GNU ld によって発行されるメッセージ形式に、より
  合わせるために行われます。

(B#47989)
- コマンドラインから重複ファイルを削除するように変更しました。ユーザ
  によって同一オブジェクト ファイルまたは静的ライブラリが指定された場
  合、リンカでは、該当ファイルの管理に使用される全メモリのコピーが
  複数作成されます。大きな静的ライブラ リの場合、これは大量の重複メモ
  リとなり、リンカがインプット ファイルを繰り返しスキャンする間、時
  間的ペナルティを受けることになります。
  これは、GNU リンカとは異なる挙動になるため、元の挙動に戻すための
  スイッチ「--no-remove-duplicate-inputs」を追加しました。

- "comdat"セクションを多用するコードをリンクするときのメモリ消費を削減
  しました。

----------------------------------------------------------------------
GCC
----------------------------------------------------------------------
<PPU/SPU共通>

(B#44753)
- internal compiler error が発生した際に、コンパイラが自動的にプリプロ
  セス済みのソースファイルを生成する機能を新規追加しました。

(B#47039)
- コンパイル時に大きなスタックの使用を警告するための、新しいオプション
  -Wframe-larger-than=を追加しました。

<PPU>

(B#50260)
- PPU GUID を埋め込むリンカオプション `-mppuguid' を新規追加しました。
  このオプションを指定してビルドした ELFファイル または PRXファイルには、
  シンボル __PPU_GUID が定義され、PPU GUID が埋め込まれます。

[仕様変更]

<PPU/SPU共通>

(B#47161)
- if文の本体が空であるという警告は、Cのフロントエンドでしか出力してい
  ませんでしたが、C++のフロントエンドでも出力するように変更しました。

(B#47622)
- 使用されていない関数と変数のデバッグ情報を削除するように変更しました。
  なお、この機能は -fno-eliminate-unused-debug-declarations を指定して
  無効にすることができます。

(B#48820)
- 初期値の指定がないstatic変数(暗黙的に0に初期化される)について、どの
  関数からもその値を設定していない場合でも、最適化が十分行われていませ
  んでしたので、完全に最適化して除去するように変更しました。

(B#49047)
- ベクトル変数のアドレスを構造体のポインタとしてキャストして、その構造
  体のベクトルフィールドのみを使用する場合、不要なロード・ストア命令が
  生成されていました。
  この不要なロード・ストア命令を生成しないように変更しました。

 例)
 -- プログラム ---
  struct A
  {
    vector float f;
  };

  struct A func(vector float f)
  {
    return *(struct A*)&f;
  }

 -- アセンブリコード(変更前) ---
  .func:
      addi 9,1,64
      addi 10,1,64
      rldicl 9,9,0,32
      rldicl 11,3,0,32
      mr 3,11
      stvx 2,0,10
      lvx 0,0,9
      stvx 0,0,11
      blr

 -- アセンブリコード(変更後) ---
  .func:
      rldicl 9,3,0,32
      mr 3,9
      stvx 2,0,9
      blr

(B#51736)
- -Osオプションを指定した際、除算に加えて少しだけ演算をするような関数
  がインライン展開されず、結果としてコードサイズが大きくなることがあり
  ました。このような関数をインライン展開するように変更しました。

(B#51861)
- -O0では、?:演算子とともにstatic const変数の値を使用すると、その変数
  が最適化で除去されないことがありましたが、除去されるように変更しま
  した。

(B#52505)
- 整数[ベクタ]という表記がCフロントエンドで受け入れられていたので、
  修正しました。C++フロントエンドでは以前からエラーにしていました。

<PPU>

(B#41204)
- コピーコンストラクタまたはoperator=を持たない、小さな構造体のコピー
  の際に、LHS（Load Hit Store）ハザードの問題が起きることがありました。
  構造体のコピーの際にLHSが起きないように変更しました。

(B#46721)
- ベクトルレジスタがスタックに保存されるときに、リンクレジスタを不必
  要にスタックに保存していたので、保存しないように変更しました。

(B#47569)
- ppu-lv2-objcopy および ppu-lv2-strip コマンドが PPU のオブジェクト
  ファイルを処理する際に、'empty lodable segment' という警告を出力し
  ないように変更しました。

(B#47617)
- libsnc.aが存在する場合、暗黙的にリンクするように変更しました。
  この変更により、以下の制限事項を解消しました。
  - SN Systemsのコンパイラ(SNC)で出力したオブジェクトファイルを、GCCの
    コンパイラドライバを使ってリンクする場合には、SNCに含まれている以下
    のライブラリを明示的にリンクするようにしてください。
    host-win32\sn\ppu\lib\libsnc.a

(B#51350)
- ppu-lv2-ldでパーシャルリンクを行う際、すべての入力ファイルについて
  SNリンカでの不要コード除去最適化が適用可能な形式であった場合は、
  パーシャルリンク後のファイルについても上記最適化を適用可能な形式で
  生成するように変更しました。

(B#44381)
- 本リリースより、PPU用コンパイラはデフォルトの状態で
  $CELL_SDK\target\ppu\include\sysからヘッダファイルを探索しなくなります。
  上記ディレクトリにインストールされているヘッダをインクルードする場合
  には、ファイル名の先頭に明示的にsys\を記述するようにしてください。
  詳細は、技術情報200805-05を参照してください。
  https://ps3.scedev.net/technotes/view/741

(B#49606)
- ベクタに比較演算子を使うと、4個またはそれ以上のスカラーの比較に分割
  されてLHSハザードが発生していました。これをAltiVec命令を直接使うよう
  に修正しました。

<SPU>

(B#45258)
- レジスタ同士のコピー命令の数を削減しました。

(B#46782)
- GCCは、間接コール命令が関数の最後のコール命令である場合に、それを
  最適化してブランチを一つ減らすように変更しました。以前は、GCCは直接
  コール命令にしかこの最適化を行いませんでした。

(B#51304)
- パフォーマンス問題を回避するため、分岐ヒント命令とhbrp命令が2サイク
  ル離れるように変更しました。
  詳細は、技術情報200804-26を参照してください。
  https://ps3.scedev.net/technotes/view/735

(B#51432)
- リンカオプション '-warn-pic-all' または '-warn-pic-code' を指定した
  際、リンカへ渡されたオブジェクトファイルに、次の命令を分岐ターゲット
  とするbrsl命令が含まれていた場合、PICファイルとみなして警告を出力し
  ないように変更しました。

(B#53091)
- オペランドがベクタの場合のfrest, frsqest, fi命令の定数畳み込みを行う
  ようにしました。

======================================================================
Release 240.001 の不具合修正
----------------------------------------------------------------------
SN Systems社製リンカ
----------------------------------------------------------------------
(B#47702)
- -1 の加数値処理に関する問題を修正しました。 SNC では、一定差異に関連
  する計算が指標値として使用される場合、配列のベースアドレスをバイアス
  する技術が使用されます。 たとえば、ソースに「arr[ind - 1]」が含まれる
  とします。「arr」が静的配列の場合、これは事実上「(arr -1)[ind]」と書
  き換えられるため、「(arr-1)」が一定となり、減法が削除されます。 
  この一定オフセット値は、リロケーションの加数に表示され、リンク時に計
  算される必要があります。残念ながら、配列のサイズが 1 でオフセットが
  -1 の場合、この問題に該当します。

(B#49539)
- -mall-base-toc オプションの使用時に、GCC によって行われる
  R_PPC64_TOC16_LO、R_PPC64_TOC16_HI、R_PPC64_TOC16_HA リロケーションに
  対するサポートを追加しました。

(B#49741)
- 不要情報の削除 (Dead stripping) に関し、.debug_line ステート マシンの
  再エンコーディングで、定位置でのエンコードではなく、別のバッファを
  使用するように修正しました。（これにより、「使用されていない関数情報
  の削除中に、ライン番号情報が拡張されました」というエラー メッセージが
  表示されていました。)

(B#49814)
- 不要情報の削除 (Dead stripping) 後に再エンコーディングする際、
  .debug_line ステート マシンに対する特殊命令コードの計算ミスによって
  引き起こされる、デバッグ ライン破損に関する問題を修正しました。

(B#48782)
- リンカが「長い」TOC切り替えコード（32ビット全部のターゲットアドレスを
  使う）ではなく「短い」TOC切り替えコード（相対ブランチで届く距離に置か
  なければならない）を使えるかどうか計算する際に、切り替えコードと呼び
  出し先のアドレスではなく、呼び出し元と呼び出し先の距離を、リンカは誤っ
  て使っていました。この不具合を修正しました。

----------------------------------------------------------------------
GCC
----------------------------------------------------------------------
<PPU/SPU共通>

(B#3225)
- 以下に示すような、ベクトル変数の初期化が使用できないという不具合を
  修正しました。

  vector signed int v1[] = {0, 1, 2, 3, 4, 5, 6, 7};
                    // v1[2] = {{0,1, 2, 3},{4, 5, 6, 7}}; と同等

  struct stypy {
    int i;
    vector signed int t;
  } v2 = {1, 0, 1, 2, 3}; // v2 ={1, {0, 1, 2, 3}}; と同等

(B#12525)
- Windows環境においてレスポンスファイルを使用している場合、空白文字を
  含むファイルパスを正しくクォートしていない不具合を修正しました。

(B#43516)
- operator=または関数呼び出しの際に、回避が困難な場合であっても
  "object of type `volatile XXX&' will not be accessed in statement"
  という警告が表示されていました。
  オーバーライドされた演算子を含む関数呼び出しに対しては、これを出力
  しないように修正しました。

(B#45657)
- コンストラクタとデストラクタの中のローカル変数に対するデバッグ情報
  が出力されないという不具合を修正しました。

(B#47733)
- 次のような internal compiler error が発生することがあった不具合を
  修正しました。
  "xxxx.c: xx: internal compiler error: in expand_stack_vars, at cfgexpand.c:725"

(B#50263)
- 最適化オプションを指定した際に、次のような internal compiler error
  が発生することがあった不具合を修正しました。
  "xxxx.c: xx: internal compiler error: in scalarize_init, at tree-sra.c:2042"

(B#50678)
- -O2以上の最適化オプション または '-fstrict-aliasing' を指定してコンパ
  イルした場合、 const修飾型から変数をアクセスする箇所で不正なコードが
  生成されることがあった不具合を修正しました。

(B#51608)
- ベクトル型の変数をラップしたクラスにおいて、次のような internal
  compiler error が発生することがあった不具合を修正しました。
  "xxxx.c: xx: internal compiler error: in expand_expr_addr_expr_1, at expr.c:6617"

(B#27899)
- 中括弧を使ったベクタリテラルを使用すると、-pedanticで警告が出るという
  不具合を修正しました。

(B#27900)
- AltiVecスタイルのベクタリテラルに符号付き整数の最小の値を指定すると、
  -pedanticでオーバーフローの警告が出るという不具合を修正しました。

(B#35165)
- GCCのreturn slot最適化は、以下の例の変数bのようなvolatile変数に誤って
  適用されていました。これをvolatile変数には使わないように変更しました。

  struct S { int x,y; };
  
  struct S test(int i) {
    struct S data;
    data.x=i; data.y=i;
    return data;
  }
  
  int main(void) {
    volatile struct S b;
    b=test(3);
    return 0;
  }

(B#39824)
- Windows Vistaでは、プリコンパイルヘッダを使うと、場合によっては次のよう
  なinternal compiler errorが発生するという不具合を修正しました。
  "internal error in mingw32_gt_pch_use_address,
   at config\i386\host-mingw32.c(141):
   MapViewOfFileEx: Attempt to access invalid address."

(B#48331)
- GCCがソースをコンパイルするのに長い時間がかかる場合がありました。
  これはレジスタアロケータの前のスケジューリングで、スケジューラの
  ready queueが巨大になるためでした。これを修正しました。

(B#52323)
- if文で終わるループのいくつかで、pragma loopが認識されないという不具
  合を修正しました。

(B#52506)
- ベクタ型の添字付けで、register指定されたベクタ変数を使用すると、エラー
  または警告が出ていたので、修正しました。

(B#52562)
- テンプレートの中のコンストラクタで初期化される、const指定された整数
  変数は、整数定数として認識されていなかったので、修正しました。

(B#52686)
- -Sオプションを使ったときにinternal compiler errorが発生すると、
  プリプロセス済みのソースがコンソールに出力されるという不具合を
  修正しました。

(B#52979)
- テンプレート引数に依存する値を使ったベクタの添え字付けが動作しない
  という不具合を修正しました。

(B#53670)
- 関数デスクリプタの一部にキャストを使ってアクセスすると次のような
  internal compiler errorが発生するという不具合を修正しました。
  "xxxx.cpp(xx): internal compiler error: in var_ann, at tree-flow-inline.h:128"

<PPU>

(B#8050)
- エラーメッセージ中では「vector bool int」が「vector unsigned int」
  と表示されるという不具合を修正しました。

(B#43009)
- packedでない構造体からpacked構造体へ、ポインタをコピーする際に、
  1バイトだけ0になってしまうという不具合を修正しました。

(B#43400)
- PPUコンパイラの場合、__builtin_expect()組み込み関数の第二引数は定数
  でなくてはなりません。本リリースのPPUコンパイラは、変数を指定すると
  エラーを報告するように修正しました。

(B#47505)
- Windowsでは、-fprofile-generateと-fprofile-arcsで.gcdaファイルの正し
  いパスを見つけられないため、これらのオプションの利用は失敗してしまう
  という不具合を修正しました。

(B#48789)
- vec_sel() と '-mbase-toc'オプションを使用すると、次のような internal
  compiler error が発生することがあった不具合を修正しました。
  "xxxx.c: xx: internal compiler error:: in reg_or_subregno, at jump.c:2036"

(B#49418)
- __attribute__((d64_abi)) について、Cell OS Lv-2 PPU ABI 仕様を満たし
  ていなかった不具合を修正しました。
  詳細は、技術情報200803-13を参照してください。
  https://ps3.scedev.net/technotes/view/706

(B#49792)
- 以前のアセンブラでは、caller と callee が同一のオブジェクトファイル
  に存在する場合、関数呼び出しのリロケーションをアセンブラ自身で解決し
  ていました。このアセンブラの仕様により、SN Systems製リンカに実装され
  ている不要コード削除最適化が有効に機能しないことがありました。
  本リリースのアセンブラでは、すべての関数呼び出しについてリロケーショ
  ンを生成するように修正しました。
  この修正により、SN製リンカはより効果的に不要コードを削除できるように
  なります。

(B#49927)
- スタックのオフセットからロードする際のベクトルロード命令に対して、
  使用しているレジスタを割り当ててしまい、値を破壊することがあった
  不具合を修正しました。

(B#51422)
- '-mprx' または '-mprx-with-runtime' を指定してPRXをリンクする際、
  $CELL_SDK\target\ppu\lib がライブラリサーチパスに含まれない不具合
  を修正しました。

(B#51468)
- 次のような internal compiler error が発生することがあった不具合を
  修正しました。
  "xxxx.c: xx: internal compiler error: in extract_insn, at recog.c:2087"

(B#51885)
- ppu_intrinsics_gcc.h にて定義されているマクロ __stdcx において、
  asm文にvolatile修飾子が欠落している不具合を修正しました。

(B#49816)
- -fmuse-save-restore-funcs指定時にリンクエラーとなる不具合を修正しま
  した。

(B#47582)
- オペランドがベクタまたは__vecreg型の除算で次のようなinternal compiler
  errorが発生するという不具合を修正しました。
  "xxxx.cpp:xx: internal compiler error: in type_after_usual_arithmetic_conversions, at cp\typeck.c:262"

(B#49742)
- 無効な__vecreg指定が、エラーではなくinternal compiler errorになって
  いたという不具合を修正しました。

(B#53071)
- vector unsigned longまたはvector signed longを使うと誤ったメッセージ
  が出力されるという不具合を修正しました。

(B#53196)
- コードによっては次のようなinternal compiler errorが発生するという
  不具合を修正しました。
  "xxxx.cpp:(xx):internal compiler error: in reg_or_subregno, at jump.c:2036"

<SPU>

(B#1760)
- 以下の不具合を修正しました。
  - spu-lv2-gccおよびspu-lv2-g++で、最適化オプション-O1以上を使用すると、
    spu_roundfおよびsi_frds組み込み関数の引数がコンパイル時に計算できる
    場合に、指定された丸めモード(デフォルトは最近値)で計算されず、切り捨てて
    計算されてしまいます。

    例)
      vec_float4 f(void) {
        return spu_roundtf(((vec_double2){
          0,12345678.9
        }));
      }

